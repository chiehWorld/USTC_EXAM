## [提纲 Sec 1-2] 算法初步 (Ch1-2)
**对应讲义：** `chap1.pdf schap1.pdf`

### 🔵 基础知识 (填空/简答)

#### 引言 (ch1)
**对应讲义：** `chap1.pdf`
1.  **算法的定义**：算法是对特定问题求解的一种计算执行描述，是由有限条精确指令组成的集合。(`chap1p19`)
    *   **特征**：
        1.  **输入**：零个或多个输入。
        2.  **输出**：一个或多个输出。
        3.  **确定性**：每条指令含义明确。
        4.  **有限性**：在有限步骤（有限时间）内结束。
        5.  **正确性**：产生正确的输出。
        6.  **通用性**：适用于同类求解问题。(`chap1p21`)
2.  **时间复杂度**：最坏情况（上界，最常用）、最好情况（下界）、平均情况（期望值）。
3.  **原址排序 (In-place)**：额外空间复杂度为 $O(1)$ 的排序（如插入排序、堆排序、快排）。
4.  **稳定性 (Stability)**：排序后，相同值的元素相对位置保持不变（如插入排序、归并排序、计数排序）。
5.  **问题实例与规模**：
    *   **问题(Problem)**：输入/输出关系的描述。
    *   **实例(Instance)**：计算一个解所需的具体输入数据（如排序的具体数组）。(`chap1p22`)
    *   **问题规模**：输入实例的大小（如数组长度 n）。(`chap1p24`)

#### 插入排序与循环不变式
1.  **插入排序算法**
    *   **思想**：类似摸牌整理。维护左侧“已排序区”，将右侧元素逐个插入到左侧正确位置。
    *   **特点**：原址排序（空间 $O(1)$），稳定排序。
2.  **算法复杂性及其度量**
    *   **度量**：主要关注**时间复杂性**（基本操作次数）和**空间复杂性**（额外存储空间）随输入规模 $n$ 的增长趋势。
    *   **情形**：
        *   **最坏情况**：运行时间的上界（保证），最常用。
        *   **最好情况**：运行时间的下界，参考价值较低。
        *   **平均情况**：基于概率分布的期望值。
3.  **插入排序的时间复杂性**
    *   **最好**：$O(n)$（输入已排好序）。
    *   **最坏**：$O(n^2)$（输入为逆序）。
    *   **平均**：$O(n^2)$。
4.  **归并排序算法及其复杂性**
    *   **思想**：**分治法**。分解 $\rightarrow$ 递归排序 $\rightarrow$ 合并 ($Merge$)。
    *   **时间**：最好、最坏、平均均为 $O(n \log n)$。
    *   **空间**：$O(n)$（需要辅助数组，非原址）。

### 🔴 解题套路：循环不变式证明
若要求证明算法（如 `SUM-ARRAY`）正确性，标准答题格式：
1.  **初始化 (Initialization)**：证明在循环第一次执行之前，不变式成立。
2.  **保持 (Maintenance)**：证明如果某次迭代开始前不变式成立，那么执行循环体后，下一次迭代开始前不变式依然成立。
3.  **终止 (Termination)**：循环结束时，利用不变式推导出算法的正确结果。

**注意**：循环不变式这个工具，主要被用来证明“循环正常结束（即没找到）”时的正确性（例v3p22）。

### 🟢 习题详解 (第1组)

**习题 2.1-1 (v3p22)**
*   **题干**：以图示说明对数组 $A=\langle 31, 41, 59, 26, 41, 58 \rangle$ 执行插入排序的过程。
*   **解答**：
    插入排序逻辑：从第2个元素开始，将其插入到前面已排序的子数组中。
    1.  初始状态: `[31], 41, 59, 26, 41, 58`
    2.  处理 41: 41 > 31, 不动 $\to$ `[31, 41], 59, 26, 41, 58`
    3.  处理 59: 59 > 41, 不动 $\to$ `[31, 41, 59], 26, 41, 58`
    4.  处理 26: 26 < 59, 26 < 41, 26 < 31, 移到最前 $\to$ `[26, 31, 41, 59], 41, 58`
    5.  处理 41: 41 < 59, 41 = 41 (插在原41后) $\to$ `[26, 31, 41, 41, 59], 58`
    6.  处理 58: 58 < 59 $\to$ `[26, 31, 41, 41, 58, 59]`

**习题 2.1-3 (v3p22)**
*   **题干**：重写线性查找问题（在序列 $A$ 中查找值 $v$）的伪代码，并使用循环不变式证明其正确性。
*   **解答**：
    *   **伪代码**：
        ```
        LINEAR-SEARCH(A, v)
        1  for i = 1 to A.length
        2      if A[i] == v
        3          return i
        4  return NIL
        ```
    *   **循环不变式**：在第 $i$ 次循环迭代开始时，子数组 $A[1..i-1]$ 中的元素都不等于 $v$。
    *   **证明**：
        *   **初始化**：$i=1$ 时，子数组 $A[1..0]$ 为空，显然不包含 $v$，性质成立。
        *   **保持**：假设第 $i$ 轮开始时 $A[1..i-1]$ 不含 $v$。若第 $i$ 轮代码没有返回，说明 $A[i] \neq v$。那么在第 $i+1$ 轮开始时，$A[1..i]$ 都不含 $v$，性质成立。
        *   **终止**：循环结束时 $i = n+1$。根据不变式，$A[1..n]$ 都不含 $v$。算法返回 NIL，正确。

**习题 2.2-2 (v3p29)**
*   **题干**：考虑选择排序：扫描整个数组找出最小元素与 $A[1]$ 交换，再扫描剩余部分找最小与 $A[2]$ 交换，以此类推。写出算法并分析最好和最坏情况的运行时间。
*   **解答**：
    *   **算法逻辑**：
        ```
        for i = 1 to n-1
            min = i
            for j = i+1 to n
                if A[j] < A[min]
                    min = j
            swap A[i], A[min]
        ```
    *   **分析**：无论输入数组是已排序还是逆序，内层循环 `for j` 始终要执行 $n-(i+1)+1 = n-i$ 次比较来寻找最小值。
    *   **总比较次数**：$\sum_{i=1}^{n-1} (n-i) = (n-1) + (n-2) + \dots + 1 = \frac{n(n-1)}{2} = \Theta(n^2)$。
    *   **结论**：最好情况和最坏情况的时间复杂度均为 $\Theta(n^2)$。

**习题 2.2-3 (v3p29)**
*   **题干**：再次考虑线性查找。在平均情况下，需要检查输入序列的多少个元素？在最坏情况下呢？用 $\Theta$ 符号表示。
*   **解答**：
    *   **平均情况**：假设元素 $v$ 等概率地出现在数组的 $n$ 个位置中的任意一个。平均查找次数为 $\frac{1+2+\dots+n}{n} = \frac{n(n+1)}{2n} = \frac{n+1}{2}$。即 $\Theta(n)$。
    *   **最坏情况**：元素 $v$ 不在数组中，或者在数组的最后一个位置。需要检查 $n$ 个元素。即 $\Theta(n)$。

**习题 2.3-2 (v3p37)**
*   **题干**：重写 MERGE 过程（v2p30），使之不使用哨兵（$\infty$，$L$ 或 $R$ 的尾元素，标志结束），而是一旦数组 $L$ 或 $R$ 的所有元素都被复制回 $A$ 就立刻停止，并将另一个数组中剩余的元素复制回 $A$。
*   **解答**：
    *   **伪代码修改思路**：
        ```
        i = 1, j = 1
        for k = p to r
            if i > n1      // L数组空了
                A[k] = R[j]
                j = j + 1
            else if j > n2 // R数组空了
                A[k] = L[i]
                i = i + 1
            else if L[i] <= R[j]
                A[k] = L[i]
                i = i + 1
            else
                A[k] = R[j]
                j = j + 1
        ```
    *   或者使用 `while` 循环比较，跳出循环后直接把非空数组的剩余部分 `append` 到 $A$ 的后面。

**习题 2.3-6 (v3p37)**
*   **题干**：注意到 `INSERTION-SORT` 的第 5-7 行的 while 循环采用一种线性查找来（反向）扫描已排好序的子数组 $A[1..j-1]$。我们可以用二分查找来把比较次数从 $\Theta(n)$ 改进为 $\Theta(\lg n)$。这是否会将插入排序的总体最坏情况运行时间改进为 $\Theta(n \lg n)$？
*   **解答**：
    *   **不能**。
    *   虽然二分查找可以将**比较次数**减少到 $O(\lg n)$，但是为了将新元素插入到正确位置，我们需要将该位置之后的所有元素向后**移动**一位。
    *   在最坏情况下（逆序），第 $j$ 次迭代需要移动 $j$ 个元素。总移动次数为 $\sum_{j=2}^n j = \Theta(n^2)$。
    *   因此，总时间复杂度由移动操作主导，依然是 $\Theta(n^2)$。

---

## [提纲 Sec 3] 函数增长率 (Ch3)

### 🔵 基础知识 (填空必考)
1.  **渐近记号**：
    *   $O(g(n))$：渐近**上界**（$\le$）。
    *   $\Omega(g(n))$：渐近**下界**（$\ge$）。
    *   $\Theta(g(n))$：渐近**紧确界**（$=$，既是上界也是下界）。
2.  **函数阶梯**（增长率从小到大）：
    $1 < \lg n < \sqrt{n} < n < n \lg n < n^2 < n^3 < 2^n < n! < n^n$
3.  **和式界的证明方法**：
    *   **数学归纳法 (Mathematical Induction)**
        *   **核心**：最严谨的证明方法。通常用于已知或猜出和式结果，需证明其正确性。
        *   **步骤**：
            1.  **猜测**和式的界。
            2.  **归纳奠基**：证明边界情况成立。
            3.  **归纳假设与推导**：假设 $n$ 时成立，证明 $n+1$ 时也成立（有时需通过减去低阶项来加强归纳假设）。
    2.  **放缩法 (Bounding the Terms)**
        *   **核心**：通过放大或缩小和式中的项来求界。
        *   **方法**：
            *   **上界**：项数 $\times$ 最大项（$\sum_{k=1}^n a_k \le n \cdot a_{max}$）。
            *   **下界**：项数 $\times$ 最小项（$\sum_{k=1}^n a_k \ge n \cdot a_{min}$）。
        *   **适用**：适用于算术级数等项之间变化不大的情况。
    3.  **拆分和式法 (Splitting Summations)**
        *   **核心**：当直接放缩得到的界太松时，将和式拆分为两部分（如前 $\lceil n/2 \rceil$ 项和剩余项）分别处理。
        *   **适用**：适用于几何级数等项之间变化剧烈的情况。通过忽略较小部分的影响，使界更紧确。
    4.  **积分法 (Approximation by Integrals)**
        *   **核心**：利用微积分中的积分来逼近和式。
        *   **适用**：当和式中的项 $f(k)$ 是单调递增或递减函数时。
        *   **结论**：$\int_{m-1}^{n} f(x)dx \le \sum_{k=m}^{n} f(k) \le \int_{m}^{n+1} f(x)dx$（以单调递增为例）。

### ✍️ 习题详解 (2nd group)

**习题 3.1-2 (v3p52)**
*   **题干**：证明对任意实常数 $a$ 和 $b$ ($b>0$)，$(n+a)^b = \Theta(n^b)$。
*   **解答**：
    *   根据定义，需证明极限 $\lim_{n \to \infty} \frac{(n+a)^b}{n^b}$ 为常数。
    *   $\lim_{n \to \infty} \frac{(n+a)^b}{n^b} = \lim_{n \to \infty} (\frac{n+a}{n})^b = \lim_{n \to \infty} (1 + \frac{a}{n})^b = (1+0)^b = 1$。
    *   因为极限是 1（非0常数），所以 $(n+a)^b = \Theta(n^b)$。

**习题 3.1-4 (v3p53)**
*   **题干**：$2^{n+1} = O(2^n)$ 成立吗？$2^{2n} = O(2^n)$ 成立吗？
*   **解答**：
    1.  对于 $2^{n+1}$：
        $2^{n+1} = 2 \cdot 2^n$。取 $c=2, n_0=1$，对于所有 $n \ge 1$，有 $2 \cdot 2^n \le 2 \cdot 2^n$。
        **成立**。
    2.  对于 $2^{2n}$：
        $2^{2n} = 4^n$。假设 $4^n \le c \cdot 2^n$，则 $2^n \le c$。
        但这对于任意大的 $n$ 是不可能成立的（$2^n$ 会趋向无穷大）。
        **不成立**。

**习题 3.2-3 (v3p59)**
*   **题干**：证明 $\lg(n!) = \Theta(n \lg n)$。
*   **解答**：
    *   利用 **斯特林公式**：$n! \approx \sqrt{2\pi n} (\frac{n}{e})^n$。
    *   $\lg(n!) \approx \lg(\sqrt{2\pi n}) + n \lg n - n \lg e = \Theta(n \lg n)$。
    *   或者用放缩法：
        *   上界：$n! \le n^n \Rightarrow \lg(n!) \le n \lg n = O(n \lg n)$。
        *   下界：$n! \ge (n/2)^{n/2} \Rightarrow \lg(n!) \ge \frac{n}{2} \lg(n/2) = \frac{n}{2}(\lg n - 1) = \Omega(n \lg n)$。
    *   综上，$\lg(n!) = \Theta(n \lg n)$。

**习题 3.2-5 (v3p60)**
*   **题干**：哪个更大：$\lg(\lg^* n)$ 还是 $\lg^*(\lg n)$？
*   **解答**：
    *   我们有 $\lg^* 2^n = 1 + \lg^* n$：
    $$
    \begin{aligned}
    \lim_{n \to \infty} \frac{\lg(\lg^* n)}{\lg^{(\lg n)}} &= \lim_{n \to \infty} \frac{\lg(\lg^{2^n})}{\lg^{(\lg 2^n)}} \\
    &= \lim_{n \to \infty} \frac{\lg(1 + \lg^* n)}{\lg^* n} \\
    &= \lim_{n \to \infty} \frac{\lg(1 + n)}{n} \\
    &= \lim_{n \to \infty} \frac{1}{1 + n} \\
    &= 0.
    \end{aligned}
    $$
    *   可得：$\lg^*(\lg n)$ 更大。

---

## [提纲 Sec 4] 递归关系式 (Ch4, Sch1)

### 🔵 基础知识 (填空必考)
**对应讲义：** `schap1.pdf`

*   **递归设计技术**：
    *   **定义**：对象部分包含自己，或过程直接/间接调用自己。(`schap1p4`)
    *   **应用场景**：递归定义（如自然数）、递归数据结构（如链表）、问题的递归解法（如汉诺塔）。(`schap1p5`)
*   **非递归化**：
    *   递归算法效率较低，常需转化。方法包括：利用栈、迭代法、末尾递归消除法。(`schap1p7`)
*   **典型算法设计**：
    *   **Fibonacci数**：典型的递归定义问题（$F_n = F_{n-1} + F_{n-2}$）。递归解法 $O(1.618^n)$，迭代解法 $O(n)$，公式法（涉及矩阵乘法）可达 $O(\log n)$。(`schap1p8`, `schap1p12`)
        *   **设计思想：**
            *   **朴素递归：** 效率极低，时间复杂度为指数级 $\Omega(2^{n/2})$，存在大量重复计算。
            *   **改进（书中暗示）：** 书中多次用它来展示递归树的指数爆炸，并引出动态规划或矩阵乘法（$O(\lg n)$）的优化思路。
    *   **生成全排列**：固定第一个元素，递归生成剩余元素的全排列，然后交换。时间 $O(n!)$。(`schap1p14-16`)
        *   **设计思想 (随机化版本)：**
            *   **原址排列 (Randomize-In-Place)：** 在遍历数组时，对于位置 $i$，从 $A[i \dots n]$ 中随机选取一个元素与 $A[i]$ 交换。
            *   **设计启示：** 这是一个典型的利用循环和交换操作来改变问题状态的例子，虽然它通常作为随机算法介绍，但其“固定一部分，处理剩余部分”的思想与递归生成全排列（回溯法）的逻辑同源。
    *   **二分查找**：将有序序列等分，比较中间元素。递归式 $T(n) = T(n/2) + O(1)$，时间 $O(\log n)$。(`schap1p22-24`)
    *   **大整数乘法**：(`schap1p28-29`)
        *   **设计思想：**
            *   普通乘法 $T(n)=4T(n/2)+O(n) \Rightarrow O(n^2)$。
            *   将 $n$ 位整数分为高位和低位两部分。
            *   利用代数技巧，将原本需要的 4 次 $n/2$ 位乘法减少为 **3 次**。
            *   $T(n) = 3T(n/2) + O(n)$。
        *   **结果：** 运行时间改进为 $O(n^{\lg 3}) \approx O(n^{1.58})$。
    *   **Strassen矩阵乘法**：(`schap1p34-36`)
        *   **设计思想：**
            *   **朴素分治：** 将矩阵分块，需要 8 次子矩阵乘法，$T(n) = 8T(n/2) + O(n^2)$，复杂度 $O(n^3)$。
            *   **Strassen 改进：** 通过构造 10 个矩阵和（加减法），将子矩阵乘法次数从 8 次减少到 **7 次**。
            *   $T(n) = 7T(n/2) + O(n^2)$。
        *   **结果：** 运行时间为 $O(n^{\lg 7}) \approx O(n^{2.81})$。

### 🔴 解题套路
#### 1. 代入法 (Substitution Method)
这是求解递归式最基本的方法，主要用于**证明**某个解是正确的。

*   **基本步骤 (猜测解 -> 数学归纳法证明)：**
    1.  **猜测 (Guess)：** 依靠经验（或通过递归树法）猜测出解的形式（例如猜测 $T(n) = O(n \lg n)$）。
    2.  **归纳证明 (Induction)：** 使用数学归纳法证明猜测的正确性。
        *   假设对于 $k < n$，该猜测成立。
        *   将猜测代入递归式，推导出对于 $n$ 也成立。
        *   **边界条件：** 验证基本情况（base cases）是否满足界限。
    3.  **微调：** 如果归纳证明中出现低阶项无法抵消的情况（例如差一个常数），可以尝试减去一个低阶项（如 $T(n) \le cn - d$）来加强归纳假设。

*   **变量变换法 (Variable Change)：**
    *   **适用场景：** 针对形式复杂的递归式，例如 $T(n) = 2T(\lfloor \sqrt{n} \rfloor) + \lg n$。
    *   **方法：** 通过变量代换（如令 $m = \lg n$，则 $\sqrt{n} = 2^{m/2}$），将原递归式转换为熟悉的线性递归式（如 $S(m) = 2S(m/2) + m$），求解后再换回原变量。

#### 2. 迭代法 / 递归树法 (Recursion-tree Method)
书中主要以“递归树”来展现迭代展开的过程。这是一种直观的方法，通常用于**生成好的猜测**，然后再用代入法验证。

*   **展开法 / 递归树 (Recursion Tree)：**
    *   **原理：** 将递归式可视化为一棵树。
        *   **节点：** 树中的每个节点代表递归中某个子问题的代价（非递归部分的开销，如 $f(n)$）。
        *   **层级：** 将原问题不断分解，直到叶节点（基本情况）。
    *   **计算步骤：**
        1.  **每层求和：** 计算每一层所有节点的代价总和。
        2.  **总体求和：** 将所有层级的代价相加。如果是几何级数增长，通常由底层主导；如果是几何级数递减，通常由根节点主导。
    *   **作用：** 它是导出解的有力工具。虽然作为严格证明稍微有些不严谨（涉及省略号和层数取整），但它能直接给出正确的渐近界，为代入法提供猜测依据。

#### 3. 主定理 (Master Theorem)
对于 $T(n) = aT(n/b) + f(n)$，比较 **$n^{\log_b a}$** 与 **$f(n)$**：
1.  **Case 1 (根大)**：若 $n^{\log_b a} > f(n)$ (多项式级差异 $n^\epsilon$) $\to T(n) = \Theta(n^{\log_b a})$。
2.  **Case 2 (相等)**：若 $n^{\log_b a} \approx f(n)$ $\to T(n) = \Theta(n^{\log_b a} \lg n)$。
    *   *扩展*：若 $f(n) = n^{\log_b a} \lg^k n$，则 $T(n) = \Theta(n^{\log_b a} \lg^{k+1} n)$。
3.  **Case 3 (f大)**：若 $f(n) > n^{\log_b a}$ (多项式级差异 $n^\epsilon$) 且 $af(n/b) \le c f(n)$ $\to T(n) = \Theta(f(n))$。

### ✍️ 习题详解 (2nd & 3rd group)

**习题 4.3-3 (v3p87)**
*   **题干**：证明 $T(n)=2T(n/2)+n \lg n$ 的解是 $T(n)=\Theta(n \lg^2 n)$。
*   **解答**：
    *   **分析**：$a=2, b=2 \to n^{\log_2 2} = n$。$f(n) = n \lg n$。$f(n)$ 比 $n$ 多一个 $\lg$ 因子（扩展 Case 2）。故解应为 $n \lg^2 n$。
    *   **代换法证明**：
        假设 $T(k) \le ck \lg^2 k$。
        $T(n) \le 2(c \frac{n}{2} \lg^2 \frac{n}{2}) + n \lg n$
        $= cn (\lg n - 1)^2 + n \lg n$
        $= cn (\lg^2 n - 2 \lg n + 1) + n \lg n$
        $= cn \lg^2 n - (2cn \lg n - n \lg n - cn)$
        只要 $c > 1/2$，括号内 $>0$，不等式成立。同理可证 $\Omega$。

**习题 4.3-6 (v3p87)**
*   **题干**：求 $T(n)=2T(n/2+17)+n$ 的渐近界。
*   **解答**：
    *   渐近分析中，常数 17 可忽略。方程近似为 $T(n) = 2T(n/2) + n$。
    *   $a=2, b=2, n^{\log_2 2} = n$。
    *   $f(n) = n$。满足 Case 2。
    *   **结论**：$T(n) = \Theta(n \lg n)$。

**习题 4.4-5 (v3p92)**
*   **题干**：用递归树求解 $T(n) = T(n-1) + T(n/2) + n$。
*   **解答**：
    *   画出递归树。根 $n$。
    *   左子树 $T(n-1)$，右子树 $T(n/2)$。
    *   **最长路径**（全走左边）：$n \to n-1 \to n-2 \dots \to 1$，深度为 $n$。
    *   这是一个极不平衡的树。其总和上界被 $T(n) \approx 2T(n-1)$ 也就是 $O(2^n)$ 限制。
    *   **结论**：$O(2^n)$。

**习题 4.4-7 (v3p93)**
*   **题干**：用递归树求解 $T(n) = 4T(n/2) + cn$。
*   **解答**：
    *   第 1 层代价：$cn$。
    *   第 2 层代价：$4 \times c(n/2) = 2cn$。
    *   第 3 层代价：$16 \times c(n/4) = 4cn$。
    *   第 $i$ 层代价：$2^{i-1} cn$。
    *   递归深度 $\lg n$。叶子数 $4^{\lg n} = n^{\lg 4} = n^2$。
    *   总代价是一个几何级数，公比为 2，由底层主导。
    *   **结论**：$\Theta(n^2)$。（主定理 Case 1 验证：$n^{\log_2 4} = n^2 > cn$）。

**习题 4.5-2 (v3p96)**
*   **题干**：求最大的整数 $a$，使得 $T(n) = aT(n/4) + n^2$ 的解为 $O(n^2)$。
*   **解答**：
    *   若解为 $O(n^2)$，也就是 $O(f(n))$，说明 $f(n)$ 必须占主导（符合主定理 Case 3）。
    *   即 $n^{\log_4 a} < n^{2-\epsilon}$。
    *   $\log_4 a < 2 \Rightarrow a < 4^2 = 16$。
    *   满足条件的最大整数 $a = 15$。

**习题 4.5-4 (v3p97)**
*   **题干**：主定理能应用于 $T(n) = 4T(n/2) + n^2 \lg n$ 吗？给出渐近界。
*   **解答**：
    *   $a=4, b=2, n^{\log_2 4} = n^2$。
    *   $f(n) = n^2 \lg n$。
    *   $f(n)$ 确实比 $n^2$ 大，但并不是多项式地大（没有多出 $n^\epsilon$），只大了一个 $\lg$ 因子。这落入了 Case 2 和 Case 3 的间隙，不能直接用标准主定理。
    *   利用**扩展 Case 2**：若 $f(n) = n^{\log_b a} \lg^k n$，则 $T(n) = \Theta(n^{\log_b a} \lg^{k+1} n)$。
    *   **结论**：$T(n) = \Theta(n^2 \lg^2 n)$。

**习题 4.2-3 & 4.2-5 (v3p82)**
*   **4.2-3 题干**：写出 Strassen 算法的方程（如上）。
*   **4.2-5 题干**：V.Pan 发现一种方法，用 143640 次乘法实现 $70 \times 70$ 的矩阵乘法。它比 Strassen 算法快吗？
    *   **解答**：
    *   Strassen 复杂度：$n^{\log_2 7} \approx n^{2.81}$。
    *   Pan 算法复杂度：$n^{\log_{70} 143640} \approx n^{2.795}$。
    *   因为 $2.795 < 2.81$，所以 Pan 的算法在渐近意义上**更快**。

---

## [提纲 Sec 5-8] 排序进阶 (Ch6-9)

### 🔵 基础知识

1.  **堆 (Heap)**：完全二叉树，大顶堆满足 $A[parent(i)] \ge A[i]$。
2.  **计数排序**：$O(n+k)$，稳定，非比较。
3.  **桶排序**：均匀分布假设，平均 $O(n)$。

#### 堆排序
*(注：本章核心在于堆的性质维护和建堆的时间复杂度，填空题常考点)*

**1. 堆的概念和存储结构**
*   **概念：** 堆（Heap）是一个**近似完全二叉树**的数据结构。
*   **存储结构：** 通常使用**数组**来实现。
    *   数组下标 $i$（从 1 开始计数）：
    *   **父节点** `PARENT(i)` = $\lfloor i/2 \rfloor$
    *   **左孩子** `LEFT(i)` = $2i$
    *   **右孩子** `RIGHT(i)` = $2i+1$
    
**2. 堆的性质和种类**
*   **最大堆 (Max-heap)：** 满足 $A[\text{PARENT}(i)] \ge A[i]$。即父节点的值 $\ge$ 子节点的值。根节点是最大元素。**（用于堆排序）**
*   **最小堆 (Min-heap)：** 满足 $A[\text{PARENT}(i)] \le A[i]$。即父节点的值 $\le$ 子节点的值。根节点是最小元素。**（用于优先队列）**
*   **高度：** 包含 $n$ 个元素的堆的高度为 $\Theta(\lg n)$。

**3. 堆的操作及其操作时间**
*   **MAX-HEAPIFY (维护/整堆)：**
    *   **功能：** 假设左右子树都是最大堆，但根节点可能违反性质，该操作让元素在树中“逐级下降”，使子树重新符合最大堆性质。
    *   **时间复杂度：** $O(\lg n)$ 或 $O(h)$。
*   **BUILD-MAX-HEAP (建堆)：**
    *   **功能：** 把一个无序数组转换为最大堆。从 $\lfloor n/2 \rfloor$ 到 1 自底向上调用 MAX-HEAPIFY。
    *   **时间复杂度：** **$O(n)$** （这是一个线性时间操作，非 $n \lg n$，常考点）。
    
**4. 堆排序算法和时间复杂性**
*   **算法流程：**
    1.  调用 `BUILD-MAX-HEAP` 将数组建成最大堆。
    2.  将根节点（最大值 $A[1]$）与末尾元素交换。
    3.  堆大小减 1，对新的根节点调用 `MAX-HEAPIFY`。
    4.  重复步骤 2-3 直到堆大小为 1。
*   **时间复杂度：** **$O(n \lg n)$**。
*   **空间复杂度：** 原址排序 (In-place)。

**5. 优先队列 (Priority Queue) 及其维护操作**
*   **定义：** 一种用来维护由一组元素构成的集合的数据结构。
*   **最大优先队列操作（基于最大堆）：**
    *   `INSERT(S, x)` (插入)：把 $x$ 放到堆底，然后向上“浮动” (Increase-Key) 调整。时间：$O(\lg n)$。
    *   `MAXIMUM(S)` (获取最大值)：直接返回 $A[1]$。时间：$\Theta(1)$。
    *   `EXTRACT-MAX(S)` (去掉并返回最大值)：将 $A[1]$ 与堆底元素交换，删除堆底，然后对根做 `MAX-HEAPIFY`。时间：$O(\lg n)$。
    *   `INCREASE-KEY(S, x, k)` (增大关键字)：将元素值增大，并向上“浮动”调整。时间：$O(\lg n)$。

#### 快速排序

**1. 快速排序算法及其时间复杂度**
*   **算法思想：** 分治法 (Divide and Conquer)。
    *   **分解：** 数组划分为两个子数组，左边 $\le$ 主元，右边 $>$ 主元。
    *   **解决：** 递归排序两个子数组。
    *   **合并：** 原址排序，无需合并。
*   **最坏时间复杂度：** **$\Theta(n^2)$**。
    *   发生情况：输入已经有序（正序或逆序），或者划分极度不平衡（如 $n-1$ 和 0）。
*   **最好时间复杂度：** **$\Theta(n \lg n)$**。
    *   发生情况：每次划分都是最平衡的（$n/2 : n/2$）。
*   **平均时间复杂度：** **$\Theta(n \lg n)$**。

**2. 随机快速排序算法及其期望时间**
*   **原理：** 在选择主元 (Pivot) 时，不是固定选择最后一个元素，而是从 $A[p \dots r]$ 中**随机**选择一个元素 $A[i]$，并与 $A[r]$ 交换，然后进行划分。
*   **目的：** 消除对输入分布的依赖，使得最坏情况极难发生。
*   **期望运行时间：** **$O(n \lg n)$**（针对任何输入）。

**3. Partition 算法 (划分)**
*   **功能：** 选定主元 $x = A[r]$，重排数组，使得所有 $\le x$ 的元素在 $x$ 左边，所有 $> x$ 的元素在 $x$ 右边，并返回主元的新下标。
*   **时间复杂度：** **$\Theta(n)$**。
*   **流程 (Lomuto 划分)：** 使用两个指针 $i$ 和 $j$。$j$ 从左向右扫描，遇到 $\le x$ 的元素就将其与 $i+1$ 位置交换，并扩展左区间。

#### 线性时间排序 (ch8)
**对应讲义：** `chap8.pdf`

*   **排序的下界**：
    *   **判定树模型**：任何基于比较的排序算法都可以用决策树表示，叶子节点代表排列结果（$n!$种）。(`chap8p5`)
    *   **定理**：最坏情况下，基于比较的排序需要 $\Omega(n \log n)$ 次比较。证明：$n! \le 2^h \Rightarrow h \ge \log(n!) \approx n \log n$。(`chap8p6`)
*  **计数排序 (Counting Sort)**：
    *   假设输入均在 $0 \sim k$ 区间内。
    *   **步骤**：统计每个元素出现次数，计算小于等于该元素的个数，放入输出数组。
    *   **时间**：$\Theta(n+k)$。稳定排序。(`chap8p8-12`)
*   **基数排序 (Radix Sort)**：
    *   按位排序（通常从低位到高位），每一位使用稳定的排序算法（如计数排序）。
    *   **时间**：$\Theta(d(n+k))$，其中 $d$ 为位数。如果 $k=O(n)$ 且 $d$ 为常数，则为线性时间。(`chap8p15-16`)
*   **桶排序 (Bucket Sort)**：
    *   假设输入均匀分布在 $[0, 1)$。
    *   将区间划分为 $n$ 个桶，将元素分配到桶中，对每个桶排序（如插入排序），最后合并。
    *   **时间**：平均情况 $\Theta(n)$。(`chap8p19-21`)

#### 中位数和顺序统计 (ch9)
**对应讲义：** `chap9.pdf`

*   **最大和最小值**：
    *   单独求最小/最大需 $n-1$ 次比较。
    *   同时求最小和最大：成对处理，先比较对内两元素，小的与当前min比，大的与当前max比。比较次数 $3\lfloor n/2 \rfloor$。(`chap9p4`)
*   **期望线性时间选择 (RandomizedSelect)**：
    *   基于快排的划分（Partition）。随机选择划分元。
    *   若划分元位置 $k=i$，返回；若 $i<k$ 在左侧找；若 $i>k$ 在右侧找。
    *   **时间**：期望 $O(n)$，最坏 $O(n^2)$。(`chap9p8-9`)
*   **最坏时间为线性的选择 (Select)**：
    *   **步骤**：
        1. 将元素每5个一组；
        2. 求每组中位数；
        3. 递归求中位数的中位数 $x$；
        4. 用 $x$ 划分数组；
        5. 根据位置递归查找。
    *   **分析**：保证划分比例较好（至少 3:7 分割）。递归式 $T(n) \le T(\lceil n/5 \rceil) + T(7n/10+6) + O(n)$，解得 $T(n)=O(n)$。(代换法，`chap9p12-15`)

### ✍️ 习题详解 (4th & 5th group)

**习题 6.2-5 (v3p156)**
*   **题干**：编写迭代版本（非递归）的 `MAX-HEAPIFY` 代码。
*   **解答**：
    ```
    MAX-HEAPIFY(A, i)
        while true
            l = LEFT(i)
            r = RIGHT(i)
            largest = i

            // 检查左孩子是否比当前节点大
            if l <= A.heap-size and A[l] > A[i]
                largest = l

            // 检查右孩子是否比当前最大者（i或l）更大
            if r <= A.heap-size and A[r] > A[largest]
                largest = r

            // 如果最大值不是当前节点 i，说明违反了堆性质
            if largest == i
                return                      // i 已经是最大的，满足堆性质，结束
            exchange A[i] with A[largest]
            i = largest                     // 指针下移，替代递归（更新 i，准备进入下一轮循环（下沉））
    ```

**习题 6.3-1 (v3p159)**
*   **题干**：图示 `BUILD-MAX-HEAP` 对 $A=\langle 5,3,17,10,84,19,6,22,9 \rangle$ 的过程。
*   **解答**：从 $\lfloor 9/2 \rfloor = 4$ 开始倒序调整。
    1.  节点 4 (10)：子节点 22, 9。换 22。序列变 $\langle ..., 22, ..., 10, 9 \rangle$。
    2.  节点 3 (17)：子节点 19, 6。换 19。
    3.  节点 2 (3)：子节点 84, 22。换 84。
    4.  节点 1 (5)：子节点 84, 19。换 84。此时 5 到了节点 2，继续下沉，与 22 换。
    *   **结果**：$\langle 84, 22, 19, 10, 3, 17, 6, 5, 9 \rangle$。

**习题 6.3-3 (v3p159)**
*   **题干**：证明：在含 $n$ 个元素的堆中，高度为 $h$ 的节点至多有 $\lceil n/2^{h+1} \rceil$ 个。
*   **解答**：
    *   归纳法证明。$h=0$ 是叶子，约 $n/2$ 个。
    *   去掉叶子后，剩下的节点数变为 $\lfloor n/2 \rfloor$，原高度 1 变为新高度 0。
    *   递推公式得 $\lceil n/2^{h+1} \rceil$。

**习题 6.4-4 (v3p160)**
*   **题干**：证明堆排序最坏情况时间是 $\Omega(n \lg n)$。
*   **解答**：
    *   堆排序核心是循环 $n$ 次，每次做 `Extract-Max`。
    *   `Extract-Max` 包含将堆尾元素移到堆顶并执行 `MAX-HEAPIFY`。
    *   堆尾元素通常很小，大概率要沉到叶子层（深度 $\approx \lg k$）。
    *   总时间 $\sum_{k=1}^n \lg k = \lg(n!) = \Theta(n \lg n)$。所以下界也是 $\Omega(n \lg n)$。

**习题 6.5-2 (v3p165)**
*   **题干**：图示 `MAX-HEAP-INSERT` 将 10 插入堆 $A=\langle 15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1 \rangle$ 的过程。
*   **解答**：
    1.  10 放入末尾 (idx 13)。
    2.  父节点 idx 6 (8)。10 > 8，交换。10 到 idx 6。
    3.  父节点 idx 3 (9)。10 > 9，交换。10 到 idx 3。
    4.  父节点 idx 1 (15)。10 < 15，停止。

**习题 6.5-8 (v3p166)**
*   **题干**：设计算法 `HEAP-DELETE(A, i)`，时间要求 $O(\lg n)$。
*   **解答**：
    *   将 $A[i]$ 替换为堆尾元素 $A[n]$。`heap-size` 减 1。
    *   令 `key` 为移上来的那个值。
    *   如果 `key` 比父节点大，执行 `HEAP-INCREASE-KEY`（上浮）。
    *   如果 `key` 比子节点小，执行 `MAX-HEAPIFY`（下沉）。
    *   由于堆高 $\lg n$，操作时间 $O(\lg n)$。

**习题 7.1-2 (v3p174)**
*   **题干**：当数组所有元素都相同时，`PARTITION` 返回什么？复杂度如何？
*   **解答**：
    *   标准 Partition 代码中，判断条件是 $A[j] \le x$。
    *   若全相同，所有元素都满足条件，指针 $i$ 会一直加到 $r-1$。
    *   最终主元和自己交换，返回 $q=r$。
    *   划分结果是子数组 $A[p..r-1]$ ($n-1$个) 和 空数组 ($0$个)。
    *   这是最坏划分，复杂度 $\Theta(n^2)$。

**习题 7.4-5 (v3p184)**
*   **题干**：对快速排序进行优化：当子数组大小 $< k$ 时不递归，改用插入排序。求 $k$ 的最佳取值。
*   **解答**：
    *   总时间为 $O(nk + n \lg(n/k))$。
    *   理论计算得 $k = \Theta(\lg n)$ 时并不比直接快排好多少。
    *   在实践中，由于插入排序常数小，通常取 $k \approx 10 \sim 20$ 能获得最佳性能。

**习题 8.2-4 (v3p197)**
*   **题干**：设计一个算法，预处理 $n$ 个整数（范围 $0$ 到 $k$），能在 $O(1)$ 时间内回答“$[a, b]$ 区间内有多少个整数”。
*   **解答**：
    1.  使用计数排序的思路，计算计数数组 $C$。
    2.  进一步计算前缀和：$P(x) = \sum\limits_{i=0}^x C[i]$。$P(x)$ 表示 $\leq x$ 的元素个数。
    3.  回答查询：$[a, b]$ 间的个数 $= P[b] - P[a-1]$。
    4.  预处理 $O(n+k)$，查询 $O(1)$。

**习题 8.4-2 (v3p204)**
*   **题干**：解释为什么桶排序最坏情况是 $\Theta(n^2)$？如何改进使其最坏为 $O(n \lg n)$？
*   **解答**：
    *   最坏情况：数据分布极不均匀，所有 $n$ 个元素落入同一个桶。标准桶排序对桶内使用**插入排序**，故为 $\Theta(n^2)$。
    *   改进：将桶内排序算法改为最坏 $O(n \lg n)$ 的算法（如归并排序或堆排序）。

**习题 9.1-1 (v3p215)**
*   **题干**：证明：在最坏情况下，找到 $n$ 个元素中第二小的元素需要 $n + \lceil \lg n \rceil - 2$ 次比较。
*   **解答**：
    1.  构建锦标赛树（两两比较，胜者晋级），找出最小值。这需要 $n-1$ 次比较。
    2.  第二小的元素一定是在“直接输给最小值”的那些元素中。
    3.  树的高度是 $\lceil \lg n \rceil$，所以最小值击败了 $\lceil \lg n \rceil$ 个对手。
    4.  在这些对手中找最小，需要 $\lceil \lg n \rceil - 1$ 次比较。
    5.  总计：$n - 1 + \lceil \lg n \rceil - 1 = n + \lceil \lg n \rceil - 2$。

**习题 9.3-6 (v3p223)**
*   **题干**：设计算法求 $k$ 分位数（将数组分为 $k$ 个大小相等的集合的 $k-1$ 个切分点），要求时间 $O(n \lg k)$。
*   **解答**：
    1.  找出数组的中位数（第 $n/2$ 小元素），作为第 $\lfloor k/2 \rfloor$ 个分位数。此步 $O(n)$。
    2.  用该中位数 Partition 数组。
    3.  递归地在左子数组找前 $k/2$ 个分位数，在右子数组找后 $k/2$ 个分位数。
    4.  递归深度 $\lg k$，每一层总工作量 $O(n)$。总时间 $O(n \lg k)$。

---

## [提纲 Sec 9-10] 红黑树 (Ch13-14)

### 🔵 基础知识 (必背)

#### 红黑树
**对应讲义：** `chap13.pdf`

*   **定义与性质**：
    1.  节点是红色或黑色。
    2.  根是黑色。
    3.  叶子（NIL）是黑色。
    4.  红节点的两个孩子必须是黑色（无连续红节点）。
    5.  从任一节点到其后代叶子的所有路径包含相同数量的黑节点（**黑高**概念）。(`chap13p7`, `chap13p9`)
*   **高度**：一棵 $n$ 个内点的红黑树高度至多为 $2\log(n+1)$。(`chap13p10`)

> ### 方法一：数学归纳法（基于黑高）
> 这是教材中（**chap13p10-11**）使用的标准证明方法，分为两个步骤。
> 
> **定义**：
> *   $bh(x)$：节点 $x$ 的**黑高**（Black-Height），即从 $x$ 出发（不含 $x$）到任意一个叶子节点的路径上的黑色节点数量。
> *   根据红黑树性质5，每个节点的黑高是唯一的。
> 
> **步骤 1：证明子树节点数与黑高的关系**
>
> **引理**：以节点 $x$ 为根的子树至少包含 $2^{bh(x)} - 1$ 个内部节点。
> *   **归纳基础**：若 $x$ 为 NIL（叶子），$bh(x)=0$。内部节点数为 0，$2^0 - 1 = 0$。命题成立。
> *   **归纳假设**：假设对于 $x$ 的左右孩子，命题成立。
> *   **归纳步骤**：设 $x$ 的两个孩子为 $left$ 和 $right$。
>     *   子树的节点总数 $size(x) = size(left) + size(right) + 1$。
>     *   根据黑高定义，孩子的黑高要么等于 $bh(x)$（孩子为红），要么等于 $bh(x)-1$（孩子为黑）。
>     *   为了求**最少**节点数，我们假设孩子都是黑色的（这样层数消耗最快），即 $bh(child) = bh(x) - 1$。
>     *   $size(x) \ge (2^{bh(x)-1} - 1) + (2^{bh(x)-1} - 1) + 1 = 2 \cdot 2^{bh(x)-1} - 1 = 2^{bh(x)} - 1$。
> *   **结论**：对于根节点，整棵树的节点数 $n \ge 2^{bh(root)} - 1$。
>     *   推导可得：$bh(root) \le \log_2(n+1)$。
> 
> **步骤 2：证明树高与黑高的关系**
> *   根据红黑树性质4（不能有两个连续的红节点），在任何从根到叶子的路径上，红色节点不能相邻。
> *   这意味着，路径上至少有一半的节点是黑色的（不包括根节点自身，根必黑，但这不影响比例的大致界限）。
> *   因此，树的总高度 $h$ 最多是黑高 $bh(root)$ 的两倍。
>     *   即 $bh(root) \ge h/2$ 或 $h \le 2 \cdot bh(root)$。
> 
> **综合结论**：$$h \le 2 \cdot bh(root) \le 2\log_2(n+1)$$
> 
> ### 方法二：利用 2-3-4 树（4阶B树）的同构性
> 这种方法对应讲义 **chap13p5** 中的图示思路，通过将红黑树转化为 B 树来直观证明。
> 
> **核心思想**：
> 红黑树在逻辑上等价于一棵 4 阶 B 树（也称为 2-3-4 树）。
> *   **转化规则**：将红黑树中的**红色节点**与其**黑色父节点**提升到同一层级（合并），作为一个超级节点。
> 
> **证明过程**：
> 1.  **节点合并**：
>     *   如果一个黑色节点没有红色孩子，它自己构成一个 2-节点（1个关键字，2个孩子）。
>     *   如果一个黑色节点有一个红色孩子，它们合并成一个 3-节点（2个关键字，3个孩子）。
>     *   如果一个黑色节点有两个红色孩子，它们合并成一个 4-节点（3个关键字，4个孩子）。
>     *   *注意：根据红黑树性质4，红色节点不能有红色孩子，所以合并后的节点内部不会冲突。*
> 
> 2.  **高度分析**：
>     *   合并后的树是一棵 B 树，其所有叶子节点都在同一深度。
>     *   设这棵 B 树的高度为 $H'$。
>     *   由于红黑树中只有黑色节点贡献了 B 树的高度，因此 $H'$ 实际上就是红黑树的**黑高**，$H' = bh(root)$。
> 
> 3.  **节点数与高度的关系**：
>     *   在包含 $n$ 个关键字的 4 阶 B 树中，若要让高度最大（即树最瘦高），每个节点应尽可能包含最少的关键字（即全是 2-节点，也就是二叉树形态）。
>     *   此时，$n \ge 2^{H'} - 1$，即 $H' \le \log_2(n+1)$。
> 
> 4.  **还原回红黑树**：
>     *   在最坏情况下（红黑树最高），红黑树中的路径是“黑-红-黑-红...”交替的。
>     *   这意味着 B 树中的每一个节点（高度为 1）在红黑树中都被展开成了 2 层（1个黑+1个红）。
>     *   因此，红黑树的最大高度 $h$ 最多是 B 树高度 $H'$ 的 2 倍。
>     *   即 $h \le 2H'$。
> 
> **综合结论**：$$h \le 2H' \le 2\log_2(n+1)$$
> 
> ### 总结
> *   **方法一（代数推导）**：利用归纳法建立 $n$ 与黑高的指数关系，再利用红节点不相邻性质建立黑高与树高的线性关系。
> *   **方法二（几何映射）**：利用红黑树与 2-3-4 树的等价性，通过 B 树的高度界限反推红黑树的高度界限。

*   **旋转**：左旋和右旋，用于调整树结构，保持二叉搜索树性质，时间 $O(1)$。(`chap13p14-16`)
*   **插入 (RBInsert)**：（了解即可，不考伪代码）
    *   先按BST插入并涂红。
    *   **调整 (RBInsertFixup)**：解决“双红”冲突。分为3种情况（关注叔叔节点的颜色）。
        *   Case 1: 叔叔为红（变色，上溯）。
        *   Case 2: 叔叔为黑且z是右孩子（左旋，转Case 3）。
        *   Case 3: 叔叔为黑且z是左孩子（变色，右旋，结束）。
    *   时间：$O(\log n)$，至多**2**次旋转。(`chap13p20-28`)
*   **删除 (RBDelete)**：（了解即可，不考伪代码）
    *   物理删除节点，若删除的是黑色节点需调整。
    *   **调整 (RBDeleteFixup)**：解决黑高不平衡。分为4种情况（关注兄弟节点 $w$）。
        *   Case 1: 兄弟 $w$ 为红。
        *   Case 2: 兄弟 $w$ 为黑且两孩子全黑。
        *   Case 3: 兄弟 $w$ 为黑，左红右黑。
        *   Case 4: 兄弟 $w$ 为黑，右红（旋转，变色，结束）。
    *   时间：$O(\log n)$，至多**3**次旋转。(`chap13p33-39`)

#### 数据结构的扩张
**对应讲义：** `chap14.pdf`

*   **动态顺序统计 (OS树)**：
    *   **扩展红黑树**：在红黑树节点增加 `size` 域（子树节点数）。(`chap14p5`)
    *   **操作**：
        *   1. `OS-Select(x, i)`: 找第 $i$ 小元素。根据左子树大小 $r$ 判断：$i=r+1$ 选中，$i<r+1$ 查左，$i>r+1$ 查右。时间 $O(\log n)$。(`chap14p7`)
        *   2. `OS-Rank(T, x)`: 求 $x$ 的排名。沿树上溯累加。时间 $O(\log n)$。(`chap14p8`)
    *   **维护**：插入/删除时通过旋转局部更新 `size`，代价 $O(1)$。(`chap14p9`)
*   **区间树**：（了解即可）
    *   **扩展**：节点存区间 $[low, high]$，附加域 `max`（子树中区间的最大端点）。(`chap14p20`)
    *   **查找**：`IntervalSearch` 查找重叠区间。利用 `max` 剪枝判断是否向左或向右子树搜索。时间 $O(\log n)$。(`chap14p21`)

### ✍️ 习题详解 (6th group)

**习题 13.1-3 (v3p311)**
*   **题干**：如果是“松弛红黑树”（根节点可以是红色），其高度还是 $O(\lg n)$ 吗？
*   **解答**：**是**。
    *   红黑树高度受限主要归功于性质4（不连红）和性质5（黑高平衡）。
    *   仅允许根为红，并不改变路径上黑节点的分布规律，也不会产生很长的纯红路径。高度仍为 $2 \lg(n+1)$ 级别。

**习题 13.3-4 (v3p322)**
*   **题干**：证明 `RB-INSERT-FIXUP` 中，如果 $z.p$ 是红色，则 $z.p.p$ 一定存在且为黑色。
*   **解答**：
    *   根据性质2，根必须是黑色。所以如果 $z.p$ 是红，它一定不是根，因此它有父节点 $z.p.p$。
    *   根据性质4，红色节点不能有红色孩子。既然 $z.p$ 是红，它的父节点 $z.p.p$ 必须是黑。

**习题 14.2-2 (v3p347)**
*   **题干**：能否在红黑树节点中维护黑高度 $bh$ 而不影响 $O(\lg n)$ 操作？
*   **解答**：
    *   可以。节点的 $bh$ 仅依赖于其子节点：$x.bh = x.left.bh + (1 \text{ if } x.left.color==BLACK)$。
    *   根据扩张定理，这种局部依赖的属性可以在旋转和插入删除时以 $O(1)$ 维护。

**习题 14.3-3 (v3p354)**
*   **题干**：设计算法，在区间树中找出与给定区间 $i$ 重叠且具有**最小低端点 (low endpoint)** 的区间。
*   **解答**：
    *   标准的 `INTERVAL-SEARCH` 总是优先查找左子树。
    *   如果左子树的 `max` $\ge$ `i.low`，则左子树**可能**有重叠区间。由于中序遍历顺序，左子树中的区间低端点一定小于当前和右子树。
    *   所以标准算法找到的第一个重叠区间，就是具有最小低端点的区间。无需修改。

---

## [提纲 Sec 11] 动态规划 (Ch15)

### 🔵 基础知识 (必背)
**对应讲义：** `chap15.pdf`

1.  **基本思想与步骤** (`chap15p9-10`)
    *   **思想**：将原问题分解为若干个**非独立**（重叠）的子问题，先求子问题，保存结果（Memoization），避免重复计算。
    *   **步骤**：
        1.  找出最优解的性质，刻画其**最优子结构**特征。
        2.  递归定义最优值（写出**动态规划方程**）。
        3.  **自底向上**计算最优值（填表）。
        4.  根据记录的信息构造最优解（如果只需要值，此步可省略）。

2.  **动态规划 vs 分治法** (`chap15p9`)
    *   **分治法**：子问题是**相互独立**的（如归并排序），通常用递归求解。
    *   **动态规划**：子问题是**重叠**的（Overlapping），用表记录结果，避免重复计算。

3.  **最优性原理 (Bellman Principle)** (`chap15p8`, `chap15p12`)
    *   **定义**：一个最优策略的**子策略**也必须是对于当前状态的最优策略。
    *   **证明方法**：**反证法**（Cut-and-Paste 剪切粘贴法）。假设子路径不是最优的，用更优的子路径替换它，从而得到一个比原“最优解”更优的解，导致矛盾。
    *   *注*：最长路径问题**不满足**最优性原理（因为子问题不独立，共享顶点）。(`chap15p14`)

4.  **算法设计（递归式是考点）**

    **(1) 多段图规划** (`chap15p21`):
    *   **递归式**：$cost(i, j) = \min \{ c(j, l) + cost(i+1, l) \}$ ，其中 $\langle j, l \rangle \in E$。
    *   自底向上反向推导。

    **(2) 矩阵链乘法** (`chap15p29`):
    *   目标：最小化标量乘法次数。
    *   **递归式**：$m[i,j] = \min_{i \le k < j} \{ m[i,k] + m[k+1,j] + p_{i-1}p_kp_j \}$。
    *   时间：$O(n^3)$。

    **(3) 最大子段和** (`chap15p41`):
    *   $b[j]$ 表示以 $a[j]$ 结尾的最大子段和。
    *   **递归式**：$b[j] = \max \{ b[j-1] + a_j, a_j \}$。
    *   时间：$O(n)$。

    **(4) 最长公共子序列 (LCS)** (`chap15p50`):
    *   $c[i,j]$ 表示 $X_i$ 和 $Y_j$ 的 LCS 长度。
    *   **递归式**：
        *   若 $i=0$ 或 $j=0$，则 $0$；
        *   若 $x_i = y_j$，则 $c[i-1, j-1] + 1$；
        *   若 $x_i \neq y_j$，则 $\max(c[i, j-1], c[i-1, j])$。
    *   时间：$O(mn)$。

    **(5) 组合数计算**
    *   $C[i][j]$ 表示从 $i$ 个不同元素中选取 $j$ 个元素的组合数（即 $\binom{i}{j}$）。
    *   **递归式**（基于帕斯卡恒等式）：
        $$
        C[i][j] = \begin{cases} 
        1 & \text{if } j = 0 \text{ or } j = i \\ 
        C[i-1][j-1] + C[i-1][j] & \text{if } 0 < j < i 
        \end{cases}
        $$
    *   **算法过程**：
        1.  建立一个二维数组（表格）`table`，大小为 $(n+1) \times (k+1)$。
        2.  **自底向上**逐行填表：外层循环 $i$ 从 $0$ 增加到 $n$。
        3.  对于每一行 $i$，处理边界条件：令 `table[i][0] = 1` 且当 $i \le k$ 时 `table[i][i] = 1`。
        4.  对于中间项 ($1 \le j < i$ 且 $j \le k$)，利用递归式计算：`table[i][j] = table[i-1][j-1] + table[i-1][j]`。
        5.  最终返回 `table[n][k]`。
    *   时间：$O(nk)$。
        *   **算法过程**：
            1.  建立一个二维数组（表格）`table`，大小为 $(n+1) \times (k+1)$。
            2.  **自底向上**逐行填表：外层循环 $i$ 从 $0$ 增加到 $n$。
            3.  对于每一行 $i$，处理边界条件：令 `table[i][0] = 1` 且当 $i \le k$ 时 `table[i][i] = 1`。
            4.  对于中间项（$1 \le j < i$ 且 $j \le k$），利用递归式计算：`table[i][j] = table[i-1][j-1] + table[i-1][j]`。
            5.  最终返回 `table[n][k]`。
        *   时间：$O(nk)$。

> ### 手动推导演示：计算 $C(4, 2)$
> 我们要计算 $C(4, 2)$，即从 4 个里选 2 个。我们需要构建一个二维表格（DP Table），自底向上填表。设 `dp[i][j]` 表示从 `i` 个里选 `j` 个。
> 
> **填表过程：**
> 
> *   **第 0 行 ($i=0$)**:
>     *   $C(0, 0) = 1$
>
> *   **第 1 行 ($i=1$)**:
>     *   $C(1, 0) = 1$
>     *   $C(1, 1) = 1$
>
> *   **第 2 行 ($i=2$)**:
>     *   $C(2, 0) = 1$
>     *   $C(2, 1) = C(1, 0) + C(1, 1) = 1 + 1 = 2$
>     *   $C(2, 2) = 1$
>
> *   **第 3 行 ($i=3$)**:
>     *   $C(3, 0) = 1$
>     *   $C(3, 1) = C(2, 0) + C(2, 1) = 1 + 2 = 3$
>     *   $C(3, 2) = C(2, 1) + C(2, 2) = 2 + 1 = 3$
>     *   $C(3, 3) = 1$
>
> *   **第 4 行 ($i=4$)**:
>     *   $C(4, 0) = 1$
>     *   $C(4, 1) = C(3, 0) + C(3, 1) = 1 + 3 = 4$
>     *   **$C(4, 2) = C(3, 1) + C(3, 2) = 3 + 3 = 6$**  <-- **得到结果**
>
> **最终的 DP 表格（杨辉三角）：**
>
> | i \ j | 0 | 1 | 2 |
> | :--- | :---: | :---: | :---: |
> | **0** | 1 | | |
> | **1** | 1 | 1 | |
> | **2** | 1 | 2 | 1 |
> | **3** | 1 | 3 | 3 |
> | **4** | 1 | 4 | **6** |

> ### 补充：矩阵链乘法求解表 (`chap15p33`)
> 
> **题目参数：**
> 给定 6 个矩阵 $\{A_1, A_2, A_3, A_4, A_5, A_6\}$，维数向量 $p = [30, 35, 15, 5, 10, 20, 25]$。
> 即：$A_1: 30 \times 35$, $A_2: 35 \times 15$, $A_3: 15 \times 5$, $A_4: 5 \times 10$, $A_5: 10 \times 20$, $A_6: 20 \times 25$。
> 
> #### 1. 最少乘法次数表 $m[i][j]$
> 计算公式：$m[i,j] = \min_{i \le k < j} \{ m[i,k] + m[k+1,j] + p_{i-1}p_k p_j \}$
> *(注：对角线 $i=j$ 时为 0，只计算 $i<j$ 的上三角部分)*
> 
> | i \ j | 1 | 2 | 3 | 4 | 5 | 6 |
> | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
> | **1** | 0 | **15750** | 7875 | 9375 | 11875 | **15125** |
> | **2** | - | 0 | **2625** | 4375 | 7125 | 10500 |
> | **3** | - | - | 0 | **750** | 2500 | 5375 |
> | **4** | - | - | - | 0 | **1000** | 3500 |
> | **5** | - | - | - | - | 0 | **5000** |
> | **6** | - | - | - | - | - | 0 |
> 
> **关键计算示例：**
> *   **$m[2][5]$ (计算 4 个矩阵 $A_2...A_5$ 的最优解):**
>     *   $k=2$: $m[2,2]+m[3,5] + 35\times15\times20 = 0 + 2500 + 10500 = 13000$
>     *   $k=3$: $m[2,3]+m[4,5] + 35\times5\times20 = 2625 + 1000 + 3500 = \mathbf{7125}$ (最小值)
>     *   $k=4$: $m[2,4]+m[5,5] + 35\times10\times20 = 4375 + 0 + 7000 = 11375$
>     *   **结果：7125**
>
> #### 2. 最优分割点表 $s[i][j]$
> 记录使 $m[i][j]$ 取得最小值的 $k$ 值（即断开位置）。
> 
> | i \ j | 1 | 2 | 3 | 4 | 5 | 6 |
> | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
> | **1** | - | 1 | 1 | 3 | 3 | **3** |
> | **2** | - | - | 2 | 3 | **3** | 3 |
> | **3** | - | - | - | 3 | 3 | 3 |
> | **4** | - | - | - | - | 4 | 5 |
> | **5** | - | - | - | - | - | 5 |
> | **6** | - | - | - | - | - | - |
> 
> **构造最优解：**
> 根据 $s[1][6] = 3$，第一刀切在 $A_3$ 后：$(A_1 A_2 A_3)(A_4 A_5 A_6)$
> 
> 查 $s[1][3] = 1$：$(A_1(A_2 A_3))$
> 
> 查 $s[4][6] = 5$：$((A_4 A_5) A_6)$
> 
> **最终结果：** $((A_1(A_2 A_3))((A_4 A_5) A_6))$

> ### 补充：最长公共子序列求解表 (`chap15p33`)
> 
> **对应课件：** Slide 53
> 
> **题目参数：**
> *   序列 $X$ (纵轴 $i$): $A, B, C, B, D, A, B$ (长度 $m=7$)
> *   序列 $Y$ (横轴 $j$): $B, D, C, A, B, A$ (长度 $n=6$)
>
> **表格说明：**
> *   表格中的数字为 $c[i][j]$ (LCS长度)。
> *   箭头表示值的来源（用于回溯构造解）：
>     *   $\nwarrow$ (左上)：当 $x_i = y_j$ 时，$c[i-1][j-1] + 1$。这是LCS的一个字符。
>     *   $\uparrow$ (上)：当 $x_i \neq y_j$ 且 $c[i-1][j] \ge c[i][j-1]$ 时。
>     *   $\leftarrow$ (左)：当 $x_i \neq y_j$ 且 $c[i-1][j] < c[i][j-1]$ 时。
> 
> | $i$ \ $j$ | 0 | 1 (**B**) | 2 (**D**) | 3 (**C**) | 4 (**A**) | 5 (**B**) | 6 (**A**) |
> | :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
> | **0** | **0** | 0 | 0 | 0 | 0 | 0 | 0 |
> | **1 (A)** | **0** | 0 $\uparrow$ | 0 $\uparrow$ | 0 $\uparrow$ | 1 $\nwarrow$ | 1 $\leftarrow$ | 1 $\nwarrow$ |
> | **2 (B)** | **0** | **1** $\nwarrow$ | 1 $\leftarrow$ | 1 $\leftarrow$ | 1 $\uparrow$ | 2 $\nwarrow$ | 2 $\leftarrow$ |
> | **3 (C)** | **0** | 1 $\uparrow$ | 1 $\uparrow$ | **2** $\nwarrow$ | 2 $\leftarrow$ | 2 $\uparrow$ | 2 $\uparrow$ |
> | **4 (B)** | **0** | 1 $\nwarrow$ | 1 $\uparrow$ | 2 $\uparrow$ | 2 $\uparrow$ | 3 $\nwarrow$ | 3 $\leftarrow$ |
> | **5 (D)** | **0** | 1 $\uparrow$ | 2 $\nwarrow$ | 2 $\uparrow$ | 2 $\uparrow$ | 3 $\uparrow$ | 3 $\uparrow$ |
> | **6 (A)** | **0** | 1 $\uparrow$ | 2 $\uparrow$ | 2 $\uparrow$ | **3** $\nwarrow$ | 3 $\uparrow$ | 4 $\nwarrow$ |
> | **7 (B)** | **0** | 1 $\nwarrow$ | 2 $\uparrow$ | 2 $\uparrow$ | 3 $\uparrow$ | **4** $\nwarrow$ | 4 $\uparrow$ |
> 
> **最长公共子序列构造（回溯路径）：**
> 从右下角 $c[7][6]=4$ 开始回溯：
> 1.  位置 $(7,6)$ ($x_7=B, y_6=A$) 不相等，箭头朝上 $\uparrow$。
> 
> *修正：图中 (7,6) 是 $\uparrow$ 还是 $\leftarrow$ 取决于算法中 `>=` 的判定。课件代码 Page 52 是 `if c[i-1,j] >= c[i,j-1] then UP`。这里 $3 < 4$ 应该不可能发生。实际上 (7,6) 的值是 $\max(c[6,6], c[7,5]) = \max(4, 4)$。根据代码应为 $\uparrow$。但 slide 53 的红色路径是从 (7,5) 过来的。为了匹配**红色路径**，我们看重点的匹配点。*
>
> **高亮的红色路径（匹配点）：**
> 1.  **(7, 5)**: $x_7=B, y_5=B$。匹配！LCS 字符 **B**。跳到 $(6,4)$。
> 2.  **(6, 4)**: $x_6=A, y_4=A$。匹配！LCS 字符 **A**。跳到 $(5,3)$。
> 3.  $(5,3)$ 到 $(3,3)$：非匹配移动。
> 4.  **(3, 3)**: $x_3=C, y_3=C$。匹配！LCS 字符 **C**。跳到 $(2,2)$。
> 5.  $(2,2)$ 到 $(2,1)$：非匹配移动。
> 6.  **(2, 1)**: $x_2=B, y_1=B$。匹配！LCS 字符 **B**。
> 
> **最终结果：** **B C A B** (长度 4)

### 🔴 解题套路：DP 四步法
1.  **定义状态**：明确 $dp[i]$ 代表什么。
2.  **转移方程**：$dp[i] = \dots$ (包含 $\min/\max$)。
3.  **边界条件**：$dp[0]$ 等。
4.  **计算顺序**：填表方向。

### ✍️ 习题详解 (7th group)

**习题 15.2-1 (v3p378)**
*   **题干**：对矩阵规模序列 $\langle 5, 10, 3, 12, 5, 50, 6 \rangle$，求矩阵链乘法的最优括号化方案。
*   **解答**：
    *   矩阵维度：$A_1: 5 \times 10, A_2: 10 \times 3, A_3: 3 \times 12, A_4: 12 \times 5, A_5: 5 \times 50, A_6: 50 \times 6$。
    *   构建 $m[1..6, 1..6]$ 表。
    *   关键计算举例：
        *   $m[1,2] = 5 \cdot 10 \cdot 3 = 150$。
        *   $m[2,3] = 10 \cdot 3 \cdot 12 = 360$。
        *   $m[1,3] = \min(m[1,1]+m[2,3]+5\cdot 10 \cdot 12, m[1,2]+m[3,3]+5\cdot 3 \cdot 12) = \min(0+360+600, 150+0+180) = 330$。
    *   最终结果需完整填表（略），最优代价 2010，括号化 $((A_1 A_2)((A_3 A_4)(A_5 A_6)))$。

**习题 15.2-5 (v3p378)**
*   **题干**：在矩阵链乘法问题中，我们需要计算多少次 $m[i, j]$？
*   **解答**：
    *   如果不使用备忘录（纯递归），计算量是指数级的 $\Omega(2^n)$。
    *   使用 DP 或备忘录，状态总数是 $\Theta(n^2)$，每个状态计算一次。总时间 $\Theta(n^3)$。

**习题 15.3-2 (v3p389)**
*   **题干**：归并排序有重叠子问题吗？
*   **解答**：**没有**。
    *   归并排序将数组 $A[1..n]$ 分为 $A[1..n/2]$ 和 $A[n/2+1..n]$。这两个区间完全不相交。
    *   这就是为什么归并排序是分治算法，而不是动态规划。

**习题 15.3-4 (v3p390)**
*   **题干**：比较带备忘录（**自顶向下**）的递归算法与 **自底向上** 的 DP 算法。
*   **解答**：
    *   **相同点**：渐近时间复杂度和空间复杂度通常相同。
    *   **不同点**：
        *   自底向上：没有递归调用的开销，常数因子小；必定计算 **所有子问题**。
        *   备忘录：**有递归开销**；但如果某些子问题不需要求解（即不必填满表格），它会更快。

**习题 15.4-1 (v3p396)**
*   **题干**：求 $X=\langle 1,0,0,1,0,1,0,1 \rangle$ 和 $Y=\langle 0,1,0,1,1,0,1,1,0 \rangle$ 的最长公共子序列 (LCS)。
*   **解答**：
    *   填表规则：若 $x_i=y_j$，左上角+1；否则取左边或上边最大。
    *   结果：`1, 0, 0, 1, 1, 0`。长度 6。

**习题 15.4-4 (v3p397)**
*   **题干**：如何仅使用 $2 \cdot \min(m, n)$ 的记录项及其 $O(1)$ 的额外空间来计算 LCS 的长度？
*   **解答**：
    *   观察 LCS 的状态转移 $c[i, j]$ 只依赖于 $c[i-1, \dots]$（上一行）和 $c[i, \dots]$（当前行）。
    *   因此，不需要存储整个 $m \times n$ 矩阵，只需保留“上一行”和“当前行”两个数组即可。计算完一行后，滚动更新。

---

## [提纲 Sec 12] 贪心算法 (Ch16)

### 🔵 基础知识 (必背)
**对应讲义：** `chap16.pdf`

1.  **基本思想与步骤** (`chap16p5-6`)
    *   **思想**：在每个阶段都做出**当前状态下**最好的选择（局部最优），不回溯。
    *   **步骤**：
        1.  从初始解出发。
        2.  依据贪心策略朝目标前进一步（选择一个解元素）。
        3.  组合成可行解。

2.  **正确性保证** (`chap16p7`)
    *   **贪心选择性质**：问题的全局最优解可以通过一系列局部最优的选择来达到。通常通过证明每一步贪心选择都包含在某个最优解中来证明。
    *   **最优子结构性质**：问题的最优解包含其子问题的最优解。

3.  **贪心 vs 动态规划** (`chap16p9`)
    *   **贪心**：自顶向下，先做选择再解子问题，不依赖子问题的解，**不回溯**。
    *   **DP**：自底向上（或带记忆递归），先解子问题再做选择，依赖子问题的解。

4.  **背包问题对比** (`chap16p10`)
    *   **小数背包（分数背包）**：
        *   允许将物品任意分割，取走物品的一部分。
        *   满足贪心选择性质（按 $v_i/w_i$ 排序），可用贪心法，时间 $O(n \log n)$。
    *   **0-1背包**：
        *   物品**不可分割**，必须全部取或不取。
        *   **不满足**贪心选择性质，必须用DP。

5.  **算法设计**
    *   **(1) 小数背包**：策略是**价值率 ($v_i/w_i$)** 从大到小优先装入。(`chap16p17`)
    *   **(2) 活动安排**：策略是按**结束时间 ($f_i$)** 非减序排序，优先选**结束最早**且相容的活动。时间 $O(n \log n)$。(`chap16p25`)
    *   **(3) 找钱问题**：策略是按**面额**从大到小找。注意：只在**特定面额体系**（如1, 5, 10, 25）下贪心有效，**一般情况需DP**。(`chap16p37`)


### ✍️ 习题详解 (8th group)

**习题 16.1-3 (v3p422)**
*   **题干**：假设我们要选择持续时间最短的活动，或者选择重叠最少的活动，这些贪心策略能得到最优解吗？
*   **解答**：**不能**。
    *   **最短时间反例**：活动 $A[1,5], B[4,8], C[7,11]$。B最短(4)，选B则AC冲突，得1个。最优选AC，得2个。
    *   **重叠最少反例**：$A[1,2], B[1,5], C[4,5], D[3,8] \dots$ 等情况，可能导致选了一个中间的，挡住了两边更多的。
    *   **结论**：只有“结束时间最早”是正确的。

**习题 16.2-3 (v3p427)**
*   **题干**：0-1 背包问题能用贪心算法求解吗？
*   **解答**：**不能**。
    *   反例：容量 50。A: 60/10, B: 100/20, C: 120/30。
    *   密度：A(6) > B(5) > C(4)。
    *   贪心选：A+B $\to$ 重30，值160。剩20空间装不下C。
    *   最优选：B+C $\to$ 重50，值220。

**习题 16.2-5 (v3p428)**
*   **题干**：描述分数背包问题的贪心算法。
*   **解答**：
    *   策略：优先拿“单价”（价值/重量）最高的。
    *   步骤：按单价排序 $\to$ 依次装入 $\to$ 若最后一件装不下，将其切分填满背包。

**习题 16.3-3 (v3p436)**
*   **题干**：推广赫夫曼编码算法到三进制编码。
*   **解答**：
    *   二叉赫夫曼每次取 2 个最小合并。
    *   三进制赫夫曼每次从优先队列取 **3个** 最小权值的节点合并，生成新节点放回。
    *   **细节**：若节点总数 $n$ 不满足 $(n-1) \pmod 2 = 0$，初始需加虚拟节点补齐。

---

## [提纲 Sec 13-14] 回溯与平摊 (Ch17)

### 🔵 基础知识 (必背)

#### 回溯算法 (sch2)
**对应讲义：** `sch2.pdf`

1.  **基本思想** (`schap2p7`)
    *   在问题的**解空间树**中，按**深度优先 (DFS)** 策略搜索。
    *   **剪枝**：当搜索到某节点，判断该节点是否包含问题的解。如果肯定不包含（不满足约束或劣于当前最优），则跳过对该子树的搜索（**剪枝**），逐层向祖先**回溯**。

2.  **术语** (`schap2p8-9`)
    *   **解空间**：所有可能解构成的树。
    *   **活结点**：自身已生成但其孩子尚未全部生成的节点。
    *   **E-结点 (扩展结点)**：当前正在生成其孩子的活结点。
    *   **死结点**：不满足约束条件或已由限界函数剪枝，不再扩展的节点。

3.  **两种解空间树** (`schap2p15`)
    *   **子集树 (Subset Tree)**：当问题是求 $n$ 个元素集合的子集（选或不选）。树高 $n$，叶子数 $2^n$。如：0-1背包。
    *   **排列树 (Permutation Tree)**：当问题是确定 $n$ 个元素的排列。树高 $n$，叶子数 $n!$。如：TSP，n后问题。

4.  **算法设计**
    *   **(1) n后问题** (`schap2p23`)：排列树（或深度为n的树）。约束：**不在同列（隐式）**、同行、同斜线。
    *   **(2) 排列生成** (`schap2p29`)：使用 `swap` 操作在排列树上进行全排列生成。
    *   **(3) 0-1背包** (`schap2p40`)：子集树。左分支（选），右分支（不选）。
        *   **剪枝**：`CurrentWeight > Capacity` (约束) 或 `CurrentValue + RemainingMaxPossibleValue < BestValue` (限界)。
    *   **(4) TSP问题** (`schap2p35`)：排列树。寻找最小成本回路。
    *   **(5) 图的遍历** (`chap22`): DFS本身就是一种回溯的基础形式。

#### 平摊分析 (ch17)
**对应讲义：** `chap17.pdf`

1.  **作用与特点** (`chap17p10`)
    *   **作用**：分析在一个操作序列中，每个操作的**平均代价**。它保证了**最坏情况下的平均性能**。
    *   **特点**：不涉及概率（不同于平均情况分析）。即便是最坏的输入序列，总成本也不会超过（平摊成本 $\times n$）。
    *   **上界保证**：所有方法的共同目标是证明 $\sum\_{i=1}^n \hat{c}\_i \ge \sum\_{i=1}^n c\_i$ （总平摊成本 $\ge$ 总实际成本）。

2.  **聚集分析法 (Aggregate Analysis)** (`chap17p14`)
    *   **方法**：直接计算 $n$ 个操作的总实际成本 $T(n)$，然后除以 $n$。
    *   **结论**：每个操作的平摊成本是 $T(n)/n$。
    *   **应用**：
        *   **栈操作**（Push, Pop, Multipop）：$n$ 次操作总成本最多 $O(n)$（因为每个元素最多进栈一次出栈一次），平摊成本 $O(1)$。
        *   **二进制计数器**：$n$ 次Increment，总翻转次数为 $2n$，平摊成本 $O(1)$。

3.  **记账分析法 (Accounting Method)** (`chap17p23-26`)
    *   **方法**：给不同操作赋予不同的费用（平摊成本 $\hat{c}_i$）。
        *   若 $\hat{c}_i > c_i$（实际成本），多出的部分存为**信用 (Credit)**。
        *   若 $\hat{c}_i < c_i$，使用之前的信用支付。
    *   **保证上界**：必须保证数据结构中的**总信用 $\ge 0$**。
    *   **应用**：
        *   **栈**：Push收2元（1元实付，1元存给Pop），Pop/Multipop收0元（用存款）。
        *   **计数器**：置1操作收2元（1元实付，1元存给置0），置0操作收0元。

4.  **势能法 (Potential Method)** (`chap17p29-32`)
    *   **方法**：定义势能函数 $\Phi(D)$ 映射数据结构状态到实数。
    *   **公式**： $\hat{c}\_i = c\_i + \Phi(D\_i) - \Phi(D\_{i-1})$
    *   **保证上界**：若 $\Phi(D_n) \ge \Phi(D_0)$，则总平摊成本 $\ge$ 总实际成本。
    *   **应用**：
        *   **栈**：$\Phi = \text{栈中元素个数}$。
        *   **计数器**：$\Phi = \text{计数器中1的个数}$。

> ### 补充：二进制计数器平摊分析的三种方法对比
>
> #### 1. 方法横向对比表
>
>| 维度 | **聚合分析法** (Aggregate Analysis) | **记账分析法** (Accounting Method) | **势能分析法** (Potential Method) |
>| :--- | :--- | :--- | :--- |
>| **核心思想** | **整体求和取平均**。<br>不关注单次，计算 $n$ 次操作的总成本 $T(n)$ 再除以 $n$。 | **预付费机制**。<br>分配固定“摊还成本”，盈余存为信用，亏损消耗信用。 | **物理势能隐喻**。<br>定义势函数 $\Phi$，摊还成本 = 实际成本 + $\Delta\Phi$。 |
>| **分析视角** | 全局视角（宏观）。 | 局部视角（微观），侧重于单独操作的收支平衡。 | 全局状态视角，侧重于系统整体状态（势能）的变化。 |
>| **计数器逻辑** | 第 $i$ 位每 $2^i$ 次翻转一次。<br>总翻转次数 $\sum \lfloor n/2^i \rfloor < 2n$。 | $0 \to 1$ 翻转支付 2 币（1 消费，1 存款）。<br>$1 \to 0$ 翻转免费（消耗存款）。 | 定义势能 $\Phi$ = 计数器中 1 的个数。<br>每次操作势能增加 $2-t$（$t$为实际翻转数）。 |
>| **数学形式** | $\frac{T(n)}{n} \le \frac{2n}{n} = 2$ | 摊还成本 $\hat{c}\_i = 2$。<br>存款余额 $\ge 0$。 | $\hat{c}\_i = c\_i + \Phi\_i - \Phi\_{i-1} = 2$。<br>需满足 $\Phi\_i \ge \Phi\_0$。 |
>
> #### 2. 方法逻辑映射
>
> *   **聚合分析**：直觉是“低位翻转频繁，高位翻转稀疏”。
>     *   推导：$Total \le n(1 + 1/2 + 1/4 + \dots) = 2n$，故平均为 2。
> *   **记账分析**：直觉是“0变1是赚钱时刻，1变0是花钱时刻”。
>     *   规则：每次充值 2 元。当位 $0 \to 1$ 时，花 1 元翻转，存 1 元在该位上；当位 $1 \to 0$ 时，取出该位之前的存款支付翻转。
> *   **势能分析**：直觉是“1越多系统越不稳定（势能越高），进位释放能量”。
>     *   推导：$\Phi = \text{1的个数}$。每次翻转 $t$ 个位（$t-1$ 个 $1 \to 0$，1 个 $0 \to 1$），实际代价 $t$。势能变化 $\Delta\Phi = 1 - (t-1) = 2 - t$。故平摊代价 $= t + (2-t) = 2$。
>
> #### 3. 关键洞察
>
> **记账法与势能法的本质等价性**：
> *   **存款 = 势能**：记账法中每个为 `1` 的位上存有 1 个信用，这完全等同于势能法中定义 $\Phi$ 为 `1` 的个数。
> *   **支付机制**：记账法用存款支付连续的进位（$1 \to 0$），势能法通过 $\Phi$ 的降低来抵消进位的高昂实际成本。

### ✍️ 习题详解 (9th group part 1)

**习题 17.1-2 (v3p456)**
*   **题干**：如果在 $k$ 位二进制计数器中不仅有 INCREMENT，还有 DECREMENT，且最坏代价也是 $\Theta(k)$。证明：$n$ 个操作序列的代价不是 $\Theta(n)$。
*   **解答**：
    *   考虑在 $2^k$ (如 100...0) 和 $2^k-1$ (如 011...1) 之间反复切换。
    *   Inc: $011 \to 100$ (翻转 $k$ 位)。
    *   Dec: $100 \to 011$ (翻转 $k$ 位)。
    *   $n$ 次操作总代价 $O(nk)$，平均代价 $O(k)$，不再是常数。

**习题 17.3-1 (v3p462)**
*   **题干**：势能函数 $\Phi$ 需要满足什么条件？
*   **解答**：
    *   必须满足 $\Phi(D_i) \ge \Phi(D_0)$ 对所有 $i$ 成立。
    *   这样才能保证 $\sum \text{平摊代价} \ge \sum \text{实际代价}$，平摊分析才有意义作为上界。

**习题 17.3-4 (v3p463)**
*   **题干**：使用势能法分析栈操作（Push, Pop, Multipop），证明平摊代价是 $O(1)$。
*   **解答**：
    *   势能函数：$\Phi(S) = |S|$ (元素个数)。
    *   **Push**: 实际 1，$\Phi$ 增 1。平摊 $= 1+1 = 2$。
    *   **Pop**: 实际 1，$\Phi$ 减 1。平摊 $= 1-1 = 0$。
    *   **Multipop(k)**: 实际 $k$，$\Phi$ 减 $k$。平摊 $= k-k = 0$。
    *   全为常数 $O(1)$。

---

## [提纲 Sec 15] 二项堆 (Ch19 v2)

### 📘 基础知识
**对应讲义：** `chap19.pdf`

1.  **为什么需要二项堆？** (`chap19p8`)
    *   **原因**：二叉堆（Binary Heap）的合并（Union）操作效率低，为 $\Theta(n)$。二项堆支持快速的合并操作，时间复杂度为 $O(\log n)$。
    *   **复杂度对比**：
        *   **二叉堆**：Insert, Extract-Min 等为 $O(\log n)$，但 Union 为 $O(n)$。
        *   **二项堆**：**Union 为 $O(\log n)$**，其他操作（Insert, Extract-Min, Delete）也保持 $O(\log n)$。
2.  **定义和存储结构** (`chap19p12-17`)
    *   **二项树 (Binomial Tree) $B_k$**：
        *   递归定义：$B_0$ 是单节点；$B_k$ 由两棵 $B_{k-1}$ 连接而成（一棵作为另一棵的根的最左孩子）。
        *   性质：高度为 $k$，节点数为 $2^k$，根的度数为 $k$。
    *   **二项堆 (Binomial Heap)**：
        *   由一组二项树组成，满足：每种度数 $k$ 的二项树至多有一棵。
        *   满足**最小堆性质**（每棵树的根节点小于其子节点）。
    *   **存储结构**：
        *   使用**左孩子-右兄弟**表示法（Left-child, right-sibling）。
        *   节点包含：`key`, `degree`, `parent`, `child`, `sibling`。
        *   堆的根节点列表按度数递增排列。
3.  **合并操作 (Union) 及过程** (`chap19p22-32`)
    *   **思想**：类似于二进制加法。
    *   **过程**：
        1.  合并两个堆的根表，按度数递增排序。
        2.  遍历根表，若遇到两个度数相同的树 $x$ 和 $next-x$，将其中根键值较大的树连接为较小树的子树（成为最左孩子），度数加 1。
        3.  处理进位，直到所有树的度数唯一。
    *   **时间**：$O(\log n)$。
4.  **应用**
    *   **优先队列**：用于需要频繁合并优先队列的场景。
    *   **图论算法**：**Prim算法**（最小生成树）可以使用二项堆作为优先队列来优化（特别是当图比较稀疏或**需要频繁合并**时）。
    *   *注：提纲中提到的“连通分量、Kruskal”通常是**不相交集**的应用，而非二项堆，请注意区分。*

### ✍️ 习题详解 (9th group part 2)

**习题 19.1-3 (v2)**
*   **题干**：二项树 $B_k$ 中深度为 $i$ 的节点数是多少？
*   **解答**：$\binom{k}{i}$。这是二项树名字的由来。

**习题 19.2-2 (v2)**
*   **题干**：描述二项堆的 UNION 操作。
*   **解答**：
    *   将两个堆的根链表归并（按度数）。
    *   遍历链表，像二进制加法一样合并相同度数的树：两棵 $B_k$ 合并成 $B_{k+1}$（比较根节点存储的关键字（Key）的值的大小，**小的做父，大的做子**）。
    *   时间 $O(\lg n)$。

**习题 19.2-6 (v2)**
*   **题干**：描述二项堆的 INSERT 操作。
*   **解答**：
    *   将新节点看作一个只包含一棵 $B_0$ 的二项堆。
    *   调用 `UNION` 合并原堆和新堆。

---

## [提纲 Sec 16] 不相交集数据结构 (Ch21)

### 📘 基础知识
**对应讲义：** `chap21.pdf`

1.  **不相交数据集概念** (`chap21p5`)
    *   维护一组动态的、两两不相交的集合 $S=\{S_1, S_2, ..., S_k\}$。
    *   每个集合由一个**代表 (Representative)** 标识。
    *   **三个基本操作**：
        *   `Make-Set(x)`: 建立新集合 $\{x\}$。
        *   `Union(x, y)`: 合并包含 $x$ 和 $y$ 的两个集合。
        *   `Find-Set(x)`: 返回 $x$ 所在集合的代表。
2.  **两种实现方式及复杂度**
    *   **(1) 链表表示 (Linked List)** (`chap21p11-14`)
        *   每个集合用一个单链表表示，表头是代表（表头不存储数据信息，只存储 *head, *tail 和 size）。
        *   每个链表节点有指针指向表头。
        *   **简单实现**：Union 时直接将一个表接到另一个表后。最坏情况 $m$ 次操作需 $O(n^2)$。
        *   **加权合并启发式 (Weighted-Union Heuristic)**：总是将**短表**拼接到**长表**后面。
            *   更新代表指针的代价分摊后，总时间复杂度优化为 **$O(m + n \log n)$**。
    *   **(2) 森林表示 (Forest/Tree)** (`chap21p18-21`)
        *   每个集合是一棵树，根是代表。节点指向父节点。
3.  **森林表示的具体实现与复杂度** (`chap21p21`)
    *   **两种启发式策略**：
        1.  **按秩合并 (Union by Rank)**：让高度（秩）较小的树根指向高度较大的树根。
        2.  **路径压缩 (Path Compression)**：在 `Find-Set` 过程中，将查找路径上的所有节点直接指向根节点（延迟更新）。
    *   **时间复杂度**：同时使用上述两种策略时，时间复杂度为 **$O(m \alpha(n))$**。
        *   $\alpha(n)$ 是阿克曼函数的反函数，增长极慢，可视为常数（在实际应用中 $\le 4$）。
4.  **应用** (`chap21p7`)
    *   **连通分量 (Connected Components)**：判断图中两点是否连通。
    *   **Kruskal算法**：用于求最小生成树，判断添加一条边是否会形成环。

### ✍️ 习题详解 (10th group)

**习题 21.3-2 (v3p572)**
*   **题干**：描述路径压缩过程。
*   **解答**：
    *   在 `Find-Set(x)` 递归查找根节点返回时，将查找路径上的每一个节点 $x, x.p, \dots$ 的父指针直接指向根节点。
    *   这使得后续查找极快。

---

## [提纲 Sec 17] 图论算法 (Ch22-Ch25)

### 📘 基础知识
**对应讲义：** `chap22-25-part1.pdf`, `chap22-25-part2.pdf`

#### 1. BFS 和 DFS 算法
*   **颜色概念** (`part1p13`)：
    *   **白色 (White)**：未被发现的节点 (Undiscovered)。
    *   **灰色 (Gray)**：已被发现但邻接表未完全探索的节点 (Discovered / Frontier)。
        *   若将灰色合并到黑色节点中，对BFS遍历无影响。
        *   若将灰色合并到黑色节点中，会影响DFS的发现/完成时间：
            *   无法进行边分类：无法区分后向边。
            *   无法进行正确的拓扑排序。
            *   无法检测环路：遇到灰色节点且不是父节点时，说明有环路。
    *   **黑色 (Black)**：已被发现且邻接表已完全探索 (Finished)。
*   **边分类**：
    *   **树边 (Tree Edge)**：在搜索树中（**遇到白色节点**）。
    *   **前向边 (Forward Edge)**：非树边，连接祖先到后代（**遇到灰色节点 → 环路**）。
    *   **后向边 (Back Edge)**：非树边，连接后代到祖先（**$u$ → $v$，且 $v$ 是 $u$ 的后代且已变黑**）。
    *   **横向边 (Cross Edge)**：非树边，连接不同分支或同一层的节点（**$u$ → $v$，且 $v$ 不是 $u$ 的后代且已变黑**）。
*   **计算过程及复杂度**：
    *   **BFS (广度优先搜索)** (`part1p11`, `part1p18`)：
        *   使用**队列 (Queue)**。计算从源点 $s$ 到所有可达节点的**最短路径距离**（边数）。
        *   时间复杂度：**$O(V+E)$** （邻接表表示）。
    *   **DFS (深度优先搜索)** (`part1p20`, `part1p27`)：
        *   使用**递归 (或栈)**。记录**发现时间 $d[v]$** 和 **完成时间 $f[v]$**。
        *   时间复杂度：**$O(V+E)$**。

#### 2. 最小生成树 (MST)
*   **基本概念** (`part1p8`, `part1p10`)：
    *   **安全边 (Safe Edge)**：加入集合 $A$ 后仍保持 $A$ 是某棵 MST 的子集的边。
    *   **轻边 (Light Edge)**：横跨某个切割（Cut）的所有边中权重最小的边。
    *   **定理**：横跨任何尊重集合 $A$ 的切割的轻边对 $A$ 也是安全的（**轻边属于安全边**）。
*   **一般算法 (Generic Algorithm)**：
    *   维护边集 $A$，初始为空。循环寻找安全边加入 $A$，直到形成生成树。
*   **Kruskal 算法** (`part1p13`, `part1p16`)：
    *   **策略**：**全局贪心**。按权重从小到大遍历所有边，若边的两个端点不在同一集合（不形成环），则加入 MST。
    *   **实现**：使用**不相交集 (Disjoint Sets)** 维护连通分量。
    *   **复杂度**：**$O(E \log E)$** （主要消耗在**排序边**上）。
*   **Prim 算法** (`part1p17`, `part1p19`)：
    *   **策略**：**局部贪心**。从任意根节点开始，每次选择连接树与非树节点的最小权重边（轻边）。
    *   **实现**：使用**优先队列 (Priority Queue)** 维护非树节点到树的最小距离。
    *   **复杂度**：
        *   二叉堆实现：**$O(E \log V)$**。
        *   斐波那契堆实现：$O(E + V \log V)$。

> ### 补充：在 Prim 算法中，主要涉及两种优先队列操作：
> 1.  **`EXTRACT-MIN`**：从队列中取出最小值的节点（执行 $|V|$ 次）。
> 2.  **`DECREASE-KEY`**：当发现更短的边时，更新队列中节点的键值（执行次数至多为 $|E|$ 次）。
> 
> ### 实现 1：基于二叉堆 (Binary Heap)
> 这是最常用的实现方式，适用于大多数**稀疏图**。
> 
> *   **数据结构**：使用数组实现的二叉最小堆。
> *   **操作复杂度**：
>     *   `EXTRACT-MIN`：二叉堆删除堆顶元素并调整，单次耗时 $O(\log V)$。
>     *   `DECREASE-KEY`：更新节点值并向上调整（上浮），单次耗时 $O(\log V)$。
> *   **总时间复杂度分析**：
>     *   $|V|$ 次 `EXTRACT-MIN` $\rightarrow O(V \log V)$
>     *   $|E|$ 次 `DECREASE-KEY` $\rightarrow O(E \log V)$
>     *   **总计**：$O(V \log V + E \log V) = O((V+E)\log V) = \boldsymbol{O(E \log V)}$ （通常 $E \ge V-1$）。
> *   **适用场景**：图比较稀疏，即 $E$ 远小于 $V^2$ 时。
> 
> ### 实现 2：基于斐波那契堆 (Fibonacci Heap)
> 这是理论上更优的实现方式，适用于**稠密图**。
> 
> *   **数据结构**：斐波那契堆（一种松散的堆结构，支持平摊分析）。
> *   **操作复杂度**：
>     *   `EXTRACT-MIN`：单次平摊耗时 $O(\log V)$ （这点与二叉堆相同）。
>     *   `DECREASE-KEY`：**这是关键区别**。斐波那契堆将减值操作优化到了**平摊 $O(1)$**。
> *   **总时间复杂度分析**：
>     *   $|V|$ 次 `EXTRACT-MIN` $\rightarrow O(V \log V)$
>     *   $|E|$ 次 `DECREASE-KEY` $\rightarrow O(E \times 1) = O(E)$
>     *   **总计**：$\boldsymbol{O(E + V \log V)}$
> *   **适用场景**：图非常稠密（$E$ 接近 $V^2$）。此时 $O(E + V \log V)$ 明显优于 $O(E \log V)$。
> 
> ### 总结对比表
> 
> | 实现方式 | Extract-Min 代价 | Decrease-Key 代价 | 总时间复杂度 | 适用场景 |
> | :--- | :--- | :--- | :--- | :--- |
> | **二叉堆** | $O(\log V)$ | $O(\log V)$ | **$O(E \log V)$** | **稀疏图** (Sparse) |
> | **斐波那契堆** | $O(\log V)$ | **$O(1)$ (平摊)** | **$O(E + V \log V)$** | **稠密图** (Dense) |

*   **贪心性质** (`part1p20`)：
    *   两者都基于贪心策略。
    *   **Kruskal**：选择**权重最小**的边（只要不构成环）。适合稀疏图（**边少选边**）。
    *   **Prim**：选择离当前树**距离最近**的节点。适合稠密图（**边多选点**）。

### ✍️ 习题详解 (10th group)

**习题 22.3-8 (v3p611)**
*   **题干**：DFS 中 $u \to v$ 且 $u.d < v.d$，则 $v$ 是后代？
*   **解答**：**不一定**。
    *   如果是横向边 $u \to v$，且 $v$ 已经在 $u$ 访问之前被访问过且结束了（例如 $w \to v$, 然后 $w \to u$）。这种情况下 $v.d < u.d$。
    *   如果 $u$ 发现时 $v$ 是白色的，则 $v$ 必为后代（白色路径定理）。
*   **总结**：
    *   只有当 $u \to v$ 是树边或前向边时，且 $u.d < v.d$，才能确定 $v$ 是 $u$ 的后代。
    *   **$v$ 是 $u$ 的后代的充分必要条件是 $u.d < v.d < v.f < u.f$**（DFS 先完成 $v$ 的访问再回溯到 $u$）。

---

## [提纲 Sec 18] 数论 (Ch31)

### 📘 基础知识
**对应讲义：** `chap31.pdf`

#### 1. gcd(a, b) 及其表示成 a, b 线性组合方法
*   **最大公约数 (GCD)**：$gcd(a, b)$ 是能同时整除 $a$ 和 $b$ 的最大正整数。
*   **欧几里得算法 (Euclid's Algorithm)**：基于递归定理 $gcd(a, b) = gcd(b, a \pmod b)$。
*   **扩展欧几里得算法 (Extended Euclid)**：(`chap31p14`)
    *   不仅求出 $d = gcd(a, b)$，还求出系数 $x, y$ 使得 $d = ax + by$。
    *   **过程**：
        1.  递归调用 $(d', x', y') \leftarrow \text{Extended-Euclid}(b, a \pmod b)$。
        2.  更新系数：$d = d', \quad x = y', \quad y = x' - \lfloor a/b \rfloor y'$。
        3.  基准情况：当 $b=0$ 时，返回 $(a, 1, 0)$。

#### 2. Euclid’s Alg. 的运行时间
*   **拉姆定理 (Lamé’s Theorem)**：如果 $a > b \ge 1$ 且 $b < F_{k+1}$（斐波那契数），则 Euclid 算法递归次数少于 $k$。
*   **复杂度**：对于两个 $\beta$ 位的数，执行算术运算次数为 $O(\beta)$，总位操作次数为 $O(\beta^3)$（若采用更紧的分析为 $O(\beta^2)$）。简单来说，运行时间与 $b$ 的十进制位数呈线性关系，即 **$O(\log b)$**。(`chap31p13`)

#### 3. 线性模方程的求解方法
*   **方程形式**：$ax \equiv b \pmod n$。(`chap31p22`)
*   **解的存在性**：方程有解当且仅当 $d | b$，其中 $d = gcd(a, n)$。
*   **求解步骤**：
    1.  使用扩展欧几里得求 $ax' + ny' = d$ 中的 $x'$。
    2.  计算特解 $x_0 = x'(b/d) \pmod n$。
    3.  **通解**：共有 $d$ 个解，分别为 $x_i = (x_0 + i(n/d)) \pmod n$，**其中 $i = 0, 1, \dots, d-1$**。

#### 4. 中国余数定理 (CRT) 及其相应线性同余方程组的求解
*   **条件**：模数 $n_1, n_2, \dots, n_k$ **两两互质**。(`chap31p31`)
*   **方程组**：$x \equiv a_i \pmod{n_i}$，对于 $i=1 \dots k$。
*   **定理**：在模 $N = n_1 n_2 \dots n_k$ 下有唯一解。
*   **求解公式**：
    $$x \equiv \sum_{i=1}^{k} a_i M_i M_i^{-1} \pmod N$$
    *   其中 $N = \prod n_i$，$M_i = N / n_i$。
    *   **$M_i^{-1}$ 是 $M_i$ 模 $n_i$ 的逆元（即 $M_i M_i^{-1} \equiv 1 \pmod{n_i}$）**，可通过扩展欧几里得求得。

> ### 补充：韩信点兵问题 (`chap31p29`, `chap31p31`)
>
> **问题描述：**
> “今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二，问物几何？”
> 即求解线性同余方程组：
> $$ \begin{cases} x \equiv 2 \pmod 3 \\ x \equiv 3 \pmod 5 \\ x \equiv 2 \pmod 7 \end{cases} $$
>
> **求解步骤 (基于中国余数定理 CRT)：**
>
> 1.  **计算总模数 $N$**：
>     $$N = n_1 \times n_2 \times n_3 = 3 \times 5 \times 7 = 105$$
>
> 2.  **计算部分积 $M_i = N/n_i$**：
>     *   $M_1 = 105 / 3 = 35$
>     *   $M_2 = 105 / 5 = 21$
>     *   $M_3 = 105 / 7 = 15$
>
> 3.  **计算模逆元 $M_i^{-1}$** (满足 $M_i \cdot M_i^{-1} \equiv 1 \pmod{n_i}$)：
>     *   **对于 $n_1=3$**：$35 \cdot y_1 \equiv 1 \pmod 3 \Rightarrow 2y_1 \equiv 1 \Rightarrow$ **$y_1 = 2$**
>     *   **对于 $n_2=5$**：$21 \cdot y_2 \equiv 1 \pmod 5 \Rightarrow 1y_2 \equiv 1 \Rightarrow$ **$y_2 = 1$**
>     *   **对于 $n_3=7$**：$15 \cdot y_3 \equiv 1 \pmod 7 \Rightarrow 1y_3 \equiv 1 \Rightarrow$ **$y_3 = 1$**
>
> 4.  **计算通解**：
>     $$x = \sum_{i=1}^{k} a_i M_i M_i^{-1} = (2 \times 35 \times 2) + (3 \times 21 \times 1) + (2 \times 15 \times 1)$$
>     $$x = 140 + 63 + 30 = 233$$
>
> 5.  **求最小正整数解**：
>     $$x \equiv 233 \pmod{105} \Rightarrow x = 23$$
>
> **结论：** 该物体的数量最少为 **23**。

#### 5. RSA 算法过程及正确性基础
*   **密钥生成**：(`chap31p35`)
    1.  随机选两个大素数 $p, q$ ($p \neq q$)。
    2.  计算 $n = pq$, $\phi(n) = (p-1)(q-1)$。
    3.  选小奇数 $e$，使 $gcd(e, \phi(n)) = 1$（即 $e$ 与 $\phi(n)$ 互素）。
    4.  计算 $d$，使 $ed \equiv 1 \pmod{\phi(n)}$。
    5.  公钥 $P_K = (e, n)$，私钥 $S_K = (d, n)$。
*   **加解密**：
    *   加密：$C = M^e \pmod n$。
    *   解密：$M = C^d \pmod n$。
*   **正确性基础**：基于 **欧拉定理 (Euler's Theorem)** 和 **费马小定理**。即 $M^{ed} \equiv M^{1 + k\phi(n)} \equiv M \pmod n$。(`chap31p36`)

#### 6. 简单素数测试算法和伪素数测试算法
*   **简单测试**：试除法，检查 $2$ 到 $\sqrt{n}$ 的因子。太慢。
*   **伪素数测试 (Pseudo-primality Testing)**：
    *   基于 **费马小定理**：若 $n$ 是素数，则 $a^{n-1} \equiv 1 \pmod n$。
    *   **算法**：随机选基 $a$，计算 $a^{n-1} \pmod n$。若不等于 1，则 $n$ 肯定是合数；若等于 1，则 $n$ **可能**是素数（称为基 $a$ 的伪素数）。
    *   **缺陷**：存在 **Carmichael 数**（如 **561**，1105），对所有互质的基 $a$ 都满足费马定理，但它是合数。(`chap31p41`)
        *   Carmichael 数属于伪素数，但伪素数不一定是 Carmichael 数（举例：**341**、645 是伪素数但不是 Carmichael 数）。

#### 7. MR (Miller-Rabin) 算法的改进措施和算法复杂性
*   **改进措施**：在计算 $a^{n-1} \pmod n$ 的过程中，进行 **二次探测 (Witness)**。检测是否存在 $1$ 的**非平凡平方根**。
    *   即：若 $x^2 \equiv 1 \pmod n$ 且 $x \neq 1, x \neq n-1$，则 $n$ 是合数。(`chap31p46`)
    *   在素数 n 上，没有非平凡平方根。

> **例子**：寻找一个数 $x$，满足 $1 < x < 7$ 且 $x^2 \equiv 1 \pmod 8$。
> 
> 1.  **平凡解**：
>     *   $1^2 = 1$ （平凡）
>     *   $7^2 = 49 = 6 \times 8 + 1 \equiv 1$ （平凡，因为 $7 \equiv -1$）
> 2.  **寻找非平凡解**：
>     *   试一试 **3**：
>         $3^2 = 9$
>         $9 \div 8 = 1 \dots 1$
>        即 $3^2 \equiv 1 \pmod 8$
>         **结论：3 是 8 的非平凡平方根。**
>     *   试一试 **5**：
>         $5^2 = 25$
>         $25 \div 8 = 3 \dots 1$
>         即 $5^2 \equiv 1 \pmod 8$
>         **结论：5 也是 8 的非平凡平方根。**

*   **算法过程**：将 $n-1$ 表示为 $2^t u$（$u$ 为奇数）。先计算 $x_0 = a^u \pmod n$，然后平方 $t$ 次。若过程中发现非平凡平方根，则 $n$ 为合数。
*   **复杂性与错误率**：
    *   时间复杂度：$O(s \log^3 n)$ （$s$ 为测试次数）。
    *   错误率：对于任意奇合数 $n$，Miller-Rabin 测试出错（误判为素数）的概率不超过 **$2^{-s}$**。与 $n$ 无关，仅与测试次数 $s$ 有关。(`chap31p51`)
        *   **错误率可控**：通过增加 $s$，可以将错误率降低到任意小。
        *   伪素数测试中，**错误率通常较高且不可控，且与 $n$ 有关**。

### 🔴 解题套路：扩展欧几里得
求解线性同余方程 $ax \equiv b \pmod n$ 的通用步骤如下：

1.  **求 GCD 与 判别**：
    计算 $d = \gcd(a, n)$。
    *   若 $d \nmid b$（$b$ 不能被 $d$ 整除），则**无解**。
    *   若 $d \mid b$，则在模 $n$ 下恰有 **$d$ 个解**。

2.  **求系数（扩展欧几里得）**：
    求解 $ax' + ny' = d$，得到系数 $x'$。

3.  **计算特解**：
    $$x_0 = x' \cdot \frac{b}{d} \pmod n$$

4.  **计算通解**：
    $$x_k = (x_0 + k \cdot \frac{n}{d}) \pmod n$$
    其中 $k = 0, 1, \dots, d-1$。

### ✍️ 习题详解 (11th group)

**习题 31.1-10 (v3p932)**
*   **题干**：GCD 递归定理。
*   **解答**：$\gcd(a, b) = \gcd(b, a \bmod b)$。

**习题 31.4-1 (v3p945)**
*   **题干**：求 $\gcd(99, 78)$ 并找出 $x, y$ 使得 $99x + 78y = \gcd$。
*   **解答**：
    *   $99 = 1 \cdot 78 + 21$
    *   $78 = 3 \cdot 21 + 15$
    *   $21 = 1 \cdot 15 + 6$
    *   $15 = 2 \cdot 6 + 3$
    *   $6 = 2 \cdot 3 + 0 \Rightarrow \gcd=3$
    *   反向：
        $3 = 15 - 2(6) = 15 - 2(21-15) = 3(15) - 2(21) = 3(78-3 \cdot 21) - 2(21) = 3(78) - 11(21) = 3(78) - 11(99-78) = 14(78) - 11(99)$
    *   结果：$x=-11, y=14$。

**习题 31.7-2 (v3p964)**
*   **题干**：RSA 系统，$p=11, q=29, e=3$，求 $d$。
*   **解答**：
    *   $n = 319, \phi(n) = 10 \times 28 = 280$。
    *   求 $3d \equiv 1 \pmod{280}$。
    *   $280 = 93 \cdot 3 + 1 \Rightarrow 1 = 280 - 93 \cdot 3$。
    *   $-93 \cdot 3 \equiv 1 \pmod{280}$。
    *   $d \equiv -93 \equiv 187 \pmod{280}$。

**习题 31.8-3 (v3p969)**
*   **题干**：Miller-Rabin 算法原理。
*   **解答**：利用费马小定理 ($a^{n-1} \equiv 1 \pmod n$) 和非凡平方根检测（$1$ 的模平方根只有 $\pm 1$）。如果违反，则是合数；如果通过多次测试，则是素数的概率很高。

---

## [提纲 Sec 19] 串匹配 (Ch32)

### 📘 基础知识
**对应讲义：** `chap32.pdf`

#### 1. 朴素的串匹配算法 (Naïve)
*   **方法**：使用循环嵌套，检查文本 $T$ 的每一个位置 $s$ 是否匹配模式 $P$。
*   **时间复杂度**：最坏情况 **$O((n-m+1)m)$**。未利用已知信息。(`chap32p11`)

#### 2. Rabin-Karp 串匹配算法
*   **方法**：利用**滚动哈希 (Rolling Hash)**。将字符串看作 $d$ 进制数，并在模 $q$ 下比较。
*   **公式**：$t_{s+1} = (d(t_s - T[s+1]h) + T[s+m+1]) \pmod q$，其中 $h = d^{m-1} \pmod q$。
    *   $t_s$ 是文本 $T[s..s+m-1]$ 的哈希值。
    *   d 是字母表大小，乘以 $d$ 相当于左移一位（进一位）。
    *   减去 $T[s+1]h$ 相当于去掉最高位，加上 $T[s+m+1]$ 相当于加上最低位。
*   **匹配过程**：若 $t_s = p$（模式的哈希值），则逐字符比较以确认匹配。
*   **时间复杂度**：
    *   预处理：$O(m)$。
    *   匹配：平均 $O(n+m)$，最坏 $O((n-m+1)m)$（当哈希冲突非常频繁时，**退化为朴素算法**）。(`chap32p13`)
*   **构造**：需要选择大的素数 $q$ 以减少伪命中（Spurious hits）。

#### 3. 有限自动机串匹配算法 (Finite Automata)
*   **方法**：预处理出一个确定性有限状态自动机 (DFA)。状态 $q$ 表示当前已匹配的模式前缀长度。
    *   适用于字母表较小且固定的情况。
*   **转移函数 $\delta(q, a)$**：输入字符 $a$ 后，最长的既是 $P$ 的前缀又是 $P_q a$ 的后缀的长度。即 $\delta(q, a) = \sigma(P_q a)$。
*   **时间复杂度**：
    *   预处理：$O(m|\Sigma|)$（$|\Sigma|$ 为字母表大小）。
    *   匹配：**$O(n)$**（每个字符仅处理一次）。(`chap32p28`)

> ### 补充：有限自动机转移函数 $\delta$ (`chap32p27`, `chap32p30`)
>
> #### **(1) 构造逻辑**
> 有限自动机的状态 $q$ 表示当前已经成功匹配了模式串 $P$ 的前缀长度。
> *   **输入**：模式串 $P[1..m]$ 和字母表 $\Sigma$。
> *   **状态集**：$0, 1, \dots, m$。初始状态为 0，接受状态为 $m$。
> *   **定义 $\delta(q, a)$**：
>     对于每一个状态 $q$ ($0 \le q \le m$) 和每一个输入字符 $a \in \Sigma$：
>     1.  构造字符串 $P_q a$（即模式串的前 $q$ 个字符加上字符 $a$）。
>     2.  找出 $P$ 的**最长前缀**，使其也是 $P_q a$ 的**后缀**。
>     3.  该最长前缀的长度即为 $\delta(q, a)$ 的值。
>     *   公式表达：$\delta(q, a) = \sigma(P_q a)$，其中 $\sigma(w)$ 是 $P$ 的最长前缀且为 $w$ 的后缀的长度。
>
> #### **(2) 构造实例**
> *   **模式串 $P$**：`ababaca` ($m=7$)
> *   **字母表 $\Sigma$**：$\{a, b, c\}$
> *   **转移表构造过程举例**：
>     *   **状态 5 (ababa) 输入 'c'**：
>         *   当前串：`ababa` + `c` = `ababac`
>         *   $P$ 的最长前缀同时也是 `ababac` 后缀的是 `ababac` 本身（长度 6）。
>         *   $\therefore \delta(5, c) = 6$。
>     *   **状态 5 (ababa) 输入 'a'**：
>         *   当前串：`ababa` + `a` = `ababaa`
>         *   后缀检查：
>             *   `ababaa` (不匹配 P 前缀)
>             *   ...
>             *   `a` (匹配 P 前缀 `a`)
>         *   $\therefore \delta(5, a) = 1$。
>     *   **状态 5 (ababa) 输入 'b'**：
>         *   当前串：`ababa` + `b` = `ababab`
>         *   后缀检查：`abab` (匹配 P 前缀 `abab`)。
>         *   $\therefore \delta(5, b) = 4$。
>
> #### **(3) 转移函数表 (Transition Table)**
>
> | 状态 $q$ | 输入 a | 输入 b | 输入 c | 对应 P 的前缀 $P_q$ |
> | :---: | :---: | :---: | :---: | :--- |
> | **0** | **1** | 0 | 0 | $\varepsilon$ (空) |
> | **1** | 1 | **2** | 0 | a |
> | **2** | **3** | 0 | 0 | ab |
> | **3** | 1 | **4** | 0 | aba |
> | **4** | **5** | 0 | 0 | abab |
> | **5** | 1 | 4 | **6** | ababa |
> | **6** | **7** | 0 | 0 | ababac |
> | **7** | 1 | 2 | 0 | ababaca (匹配完成) |

#### 4. KMP 串匹配算法 (Knuth-Morris-Pratt)
*   **方法**：利用**前缀函数 (Prefix Function, $\pi$)**，当失配时，根据 $\pi$ 值跳转，避免回溯文本指针。
    *   改进了朴素算法：窗口可移动多于 1 位。
    *   改进了有限自动机算法：预处理时间从 $O(m|\Sigma|)$ 降到 $O(m)$。
*   **时间复杂度**：
    *   预处理（计算 $\pi$）：$O(m)$。
    *   匹配：**$O(n)$**。
    *   总时间：$O(n+m)$。(`chap32p43`)

> ### 补充：KMP 算法前缀函数 $\pi$ (`chap32p34-36`)
>
> #### **(1) 构造逻辑**
> 前缀函数 $\pi[q]$ 存储的是模式串前缀 $P_q$ 的**最长真前缀**的长度，该前缀同时也是 $P_q$ 的**后缀**。这一信息用于在失配时避免回溯文本指针。
>
> *   **算法思路** (模式串自己匹配自己)：
>     1.  初始化：$\pi[1] = 0$，$k = 0$（$k$ 代表当前匹配的长度）。
>     2.  遍历 $q$ 从 2 到 $m$（计算每个位置的 $\pi$ 值）：
>         *   **回退**：当 $k > 0$ 且下一个字符 $P[k+1] \neq P[q]$ 时，令 $k = \pi[k]$（利用已知信息递归回退，直到找到匹配或 $k=0$）。
>         *   **推进**：如果 $P[k+1] == P[q]$，则 $k = k + 1$。
>         *   **赋值**：$\pi[q] = k$。
>
> #### **(2) 构造实例**
> *   **模式串 $P$**：`ababababca` ($m=10$)
>
> | $i$ | $P[i]$ | $\pi[i]$ | 构造分析 |
> | :-: | :-: | :-: | :--- |
> | **1** | **a** | **0** | $\pi[1]$ 总是 0 |
> | **2** | **b** | **0** | $P[2]$('b') != $P[1]$('a'), 无公共前后缀 |
> | **3** | **a** | **1** | $P[3]$('a') == $P[1]$('a'), 长度 1 ("a") |
> | **4** | **b** | **2** | 接上文, $P[4]$('b') == $P[2]$('b'), 长度 1+1=2 ("ab") |
> | **5** | **a** | **3** | 接上文, $P[5]$('a') == $P[3]$('a'), 长度 2+1=3 ("aba") |
> | **6** | **b** | **4** | 接上文, $P[6]$('b') == $P[4]$('b'), 长度 3+1=4 ("abab") |
> | **7** | **a** | **5** | 接上文, $P[7]$('a') == $P[5]$('a'), 长度 4+1=5 ("ababa") |
> | **8** | **b** | **6** | 接上文, $P[8]$('b') == $P[6]$('b'), 长度 5+1=6 ("ababab") |
> | **9** | **c** | **0** | $P[9]$('c') != $P[7]$('a')。回退 $k=\pi[6]=4$。$P[9]$ != $P[5]$。回退 $k=\pi[4]=2$。$P[9]$ != $P[3]$。回退 $k=\pi[2]=0$。无匹配。 |
> | **10**| **a** | **1** | $k=0$, $P[10]$('a') == $P[1]$('a'), 长度 1 |
>
> #### **(3) $\pi$ 函数结果表**
>
> | $i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
> | :--- | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
> | **$P[i]$** | a | b | a | b | a | b | a | b | c | a |
> | **$\pi[i]$** | **0** | **0** | **1** | **2** | **3** | **4** | **5** | **6** | **0** | **1** |

#### 5. 重点掌握 Π 函数和 Δ 函数构造方法
*   **KMP的前缀函数 $\pi[q]$** (`chap32p36`)：
    *   **定义**：$\pi[q]$ 是模式串前缀 $P_q$ 的**最长真前缀**的长度，该前缀同时也是 $P_q$ 的后缀。
    *   **构造逻辑**：将模式串 $P$ 自己与自己匹配。
        ```text
        Let k = pi[q-1]
        While k > 0 and P[k+1] != P[q]:
            k = pi[k]
        If P[k+1] == P[q]:
            k = k + 1
        pi[q] = k
        ```
*   **有限自动机的转移函数 $\delta$** (`chap32p27`)：
    *   $\delta(q, a)$ 指在状态 $q$ 读入字符 $a$ 后跳转到的状态。
    *   状态值等于：字符串 $P_q a$ 的最长后缀，且该后缀是 $P$ 的前缀的长度。

### ✍️ 习题详解 (12th group)

**习题 32.1-2 (v3p988)**
*   **题干**：模式串无重复字符时的朴素优化。
*   **解答**：如果失配，因为 $P$ 无重复，已匹配部分不可能包含 $P$ 的前缀。可以直接将 $P$ 移动到失配字符之后。时间 $O(n)$。

**习题 32.4-1 (v3p1006)**
*   **题干**：求 $P=\text{ababaca}$ 的 $\pi$ 数组。
*   **解答**：
    *   `a`: 0
    *   `ab`: 0
    *   `aba`: 'a'='a' $\to$ 1
    *   `abab`: 'ab'='ab' $\to$ 2
    *   `ababa`: 'aba'='aba' $\to$ 3
    *   `ababac`: 'c' $\ne$ 'b'($\pi[5]$), 'c' $\ne$ 'a' $\to$ 0
    *   `ababaca`: 'a'='a' $\to$ 1
    *   `[0, 0, 1, 2, 3, 0, 1]`

**习题 32.4-5 (v3p1006)**
*   **题干**：何时 $\pi[i] = i-1$？
*   **解答**：当模式串是单一字符重复时，如 `aaaaa`。

---

## [提纲 Sec 20] NPC (Ch34)

### 🔵 基础知识


#### 1. 算法的严格定义
*   **定义**：算法是一个计算过程，**对于给定的输入，在有限时间内产生输出**。它通常由图灵机（Turing Machine）模型来形式化定义。

#### 2. 几种计算模型的语言识别能力
*   **确定性有限自动机 (DFA)**：识别正则语言 (Regular Languages)。
*   **下推自动机 (PDA)**：识别上下文无关语言 (Context-Free Languages)。
*   **线性有界自动机**：识别上下文相关文法语言 (Context-Sensitive Languages)。
*   **图灵机 (TM)**：识别递归可枚举语言 (Recursively Enumerable Languages)。

#### 3. 两类图灵机模型
*   **确定性图灵机 (DTM)**：每一步的转移是唯一（根据当前状态 + 读入内容）的。对应复杂性类 **P**。
*   **非确定性图灵机 (NDTM)**：每一步可以有多个（有限个）选择（“猜”一个正确路径，类似于生成一颗“计算树”）。对应复杂性类 **NP**。

#### 4. P、NP 和 NPC 问题
*   **P 类 (Polynomial)**：能在多项式时间内被**确定性**算法**解决**的问题。
*   **NP 类 (Non-deterministic Polynomial)**：能在多项式时间内被**非确定性**算法解决的问题；或者说，其解能在多项式时间内被**验证**的问题。
*   **NP 完全 (NPC)**：
    1.  它属于 NP。
    2.  所有的 NP 问题都能在多项式时间内**归约 (Polynomial-time Reducible)** 到它。
    *   **P 归约 ($A \le_p B$)**：如果问题 A 的实例可以转化为问题 B 的实例，且转化过程是多项式时间的，则称 A 可归约为 B。这意味着 B 至少比 A **难**。


> ### 直觉比喻
> * P：容易的问题，像“在一个名单里找人”。
> * NP：难解但易验证的问题，像“数独”或“拼图”——很难找到解，但给你一个填好的盘面，很容易检查是否正确。
> * NPC：NP 中最难的问题，像“所有谜题之母”——如果能快速解决其中一个，就能快速解决所有 NP 问题。
> * NP-Hard：至少和 NPC 一样难的问题，有些甚至无解（像“预测未来”）。